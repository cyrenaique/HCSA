<?xml version="1.0"?>
<doc>
    <assembly>
        <name>LibMath</name>
    </assembly>
    <members>
        <member name="M:IM.Library.Mathematics.Fractal.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:IM.Library.Mathematics.Fractal.CreateHistogram(System.Single[])">
            <summary> Creates a histogram for a float array with a unit step </summary>
            <param name="data"> The image </param>
            <returns> An array containing one histogram / band </returns>
        </member>
        <member name="M:IM.Library.Mathematics.Fractal.GetFractalDimByDifferentialBoxCounting(IM.Imaging.Image3D,System.Int32,System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="InputImage"></param>
            <param name="InputChannel"></param>
            <param name="s">Grid Size</param>
            <returns></returns>
        </member>
        <member name="M:IM.Library.Mathematics.Fractal.GetFractalDim_DifferentialBoxCounting(IM.Imaging.Image3D,System.Int32)">
            <summary>
            
            </summary>
            <param name="InputImage"></param>
            <param name="InputChannel"></param>
            <returns></returns>
        </member>
        <member name="T:IM.Library.Mathematics.NumericalRecipes">
            <remarks> Interface for Numerical Recipes Second Edition, W.H. Press, 
            </remarks>
            <list type="table">
            <listheader> <term>Version</term> <description>Changes</description> </listheader>
            <item> <term>2.0</term> <description>(AD) migrated to object framework</description> </item>
            <item> <term>1.3</term> <description>(AD) changed routines name to upper-case to match C# naming convention</description> </item>
            <item> <term>1.2</term> <description>(AD) added "select"</description> </item>
            <item> <term>1.1</term> <description>(AD) added "moment"</description> </item>
            <item> <term>1.0</term> <description>(AD) first operational build, contains "convlv", "correl", "four1", "fourn", "realft", "rlft3" and "twofft"</description> </item>
            </list>
            <remarks> Interface for Numerical Recipes Second Edition, W.H. Press, 
            </remarks>
            <list type="table">
            <listheader> <term>Version</term> <description>Changes</description> </listheader>
            <item> <term>2.0</term> <description>(AD) migrated to object framework</description> </item>
            <item> <term>1.3</term> <description>(AD) changed routines name to upper-case to match C# naming convention</description> </item>
            <item> <term>1.2</term> <description>(AD) added "select"</description> </item>
            <item> <term>1.1</term> <description>(AD) added "moment"</description> </item>
            <item> <term>1.0</term> <description>(AD) first operational build, contains "convlv", "correl", "four1", "fourn", "realft", "rlft3" and "twofft"</description> </item>
            </list>
            <remarks> Interface for Numerical Recipes Second Edition, W.H. Press, 
            </remarks>
            <list type="table">
            <listheader> <term>Version</term> <description>Changes</description> </listheader>
            <item> <term>2.0</term> <description>(AD) migrated to object framework</description> </item>
            <item> <term>1.3</term> <description>(AD) changed routines name to upper-case to match C# naming convention</description> </item>
            <item> <term>1.2</term> <description>(AD) added "select"</description> </item>
            <item> <term>1.1</term> <description>(AD) added "moment"</description> </item>
            <item> <term>1.0</term> <description>(AD) first operational build, contains "convlv", "correl", "four1", "fourn", "realft", "rlft3" and "twofft"</description> </item>
            </list>
            <remarks> Interface for Numerical Recipes Second Edition, W.H. Press, 
            </remarks>
            <list type="table">
            <listheader> <term>Version</term> <description>Changes</description> </listheader>
            <item> <term>2.0</term> <description>(AD) migrated to object framework</description> </item>
            <item> <term>1.3</term> <description>(AD) changed routines name to upper-case to match C# naming convention</description> </item>
            <item> <term>1.2</term> <description>(AD) added "select"</description> </item>
            <item> <term>1.1</term> <description>(AD) added "moment"</description> </item>
            <item> <term>1.0</term> <description>(AD) first operational build, contains "convlv", "correl", "four1", "fourn", "realft", "rlft3" and "twofft"</description> </item>
            </list>
        </member>
        <member name="M:IM.Library.Mathematics.NumericalRecipes.#ctor">
            <summary> Creates a new instance of the Numerical Recipes Toolbox 
            </summary>
        </member>
        <member name="M:IM.Library.Mathematics.NumericalRecipes.Moment(System.Single[],System.Single@,System.Single@,System.Single@,System.Single@,System.Single@)">
            <summary> Returns the average, average deviation, standard deviation, skewness and kurtosis of the input array
            </summary>
            <param name="data">the input array</param>
            <param name="average">the average</param>
            <param name="averageDeviation">the average deviation</param>
            <param name="standardDeviation">the standard deviation</param>
            <param name="skewness">the skewness</param>
            <param name="kurtosis">the kurtosis</param>
        </member>
        <member name="M:IM.Library.Mathematics.NumericalRecipes.Select(System.Int32,System.Single[])">
            <summary> Returns the k-th smallest value in the input array
            The input array will be rearranged such that the wanted value is located at data[k-1],
            Lower values will be stored in arbitrary order in data[0 .. k-2]
            Higher values will be stored in arbitrary order in data[k .. end]
            </summary>
            <param name="k">rank of the value to find</param>
            <param name="data">the input data</param>
            <returns>The k-th smallest value in the input array</returns>
        </member>
        <member name="M:IM.Library.Mathematics.NumericalRecipes.Pwt(System.Double[],System.UInt64,System.Int32,System.Int32)">
            <summary> Partial wavelet transform.
            Applies an arbitrary wavelet filter to the given vector.
            Used hierarchically by routines wt1 and wtn.
            A call to this method must be preceded by an initilization through PwtSet.
            </summary>
            <param name="a">the data to transform</param>
            <param name="n"> the size of the data</param>
            <param name="isign">the tranform direction: 1 = forward, -1 = reverse</param>
        </member>
        <member name="M:IM.Library.Mathematics.NumericalRecipes.Wtn(System.Double[],System.UInt64[],System.Int32,System.Int32,System.UInt64,System.Int32)">
            <summary>
            Replaces a by its ndim-dimensional discrete wavelet transform, if isign is input as 1. Here
            nn[0..ndim-1] is an integer array containing the lengths of each dimension (number of real
            values), which MUST all be powers of 2. output is a real array of length equal to the product of
            these lengths, in which the data are stored as in a multidimensional real array. If isign is input
            as -1, a is replaced by its inverse wavelet transform. The routine wtstep, whose actual name
            must be supplied in calling this routine, is the underlying wavelet filter. Examples of wtstep
            are daub4 and pwt.
            </summary>
        </member>
        <member name="M:IM.Library.Mathematics.NumericalRecipes.Frprmn(System.Double[],System.Double,IM.Library.Delegates.FunctionDAtoD,System.Int32@)">
            <summary>N-dimensional Fletcher-Reeves-Polak-Ribiere minimization of a function given a starting point and the gradient function
            </summary>
            <param name="p">the N-dimensional starting point</param>
            <param name="ftol">the convergence tolerance</param>
            <param name="func">the function to minimize</param>
            <param name="iter">the number of iterations performed</param>
        </member>
        <member name="M:IM.Library.Mathematics.NumericalRecipes.Frprmn(System.Double[],System.Double,System.Single,IM.Library.Delegates.FunctionDAtoD,System.Int32@)">
            <summary>N-dimensional Fletcher-Reeves-Polak-Ribiere minimization of a function given a starting point and the gradient function
            </summary>
            <param name="p">the N-dimensional starting point</param>
            <param name="ftol">the convergence tolerance</param>
            <param name="func">the function to minimize</param>
            <param name="iter">the number of iterations performed</param>
        </member>
        <member name="M:IM.Library.Mathematics.NumericalRecipes.Linmin(System.Double[],System.Double[],IM.Library.Delegates.FunctionDAtoD)">
            <summary> Moves a point toward a minimum of the given function in the given direction
            </summary>
            <param name="p">the starting point (will be replaced by the arrival point)</param>
            <param name="xi">the movement direction (will be replaced by the effective displacement vector of p</param>
            <param name="func">the function to minimize</param>
            <returns>the value of func at the arrival location p</returns>
        </member>
        <member name="M:IM.Library.Mathematics.NumericalRecipes.Brent(System.Double,System.Double,System.Double,IM.Library.Mathematics.NumericalRecipes.F1dimDelegate,System.Int32,System.Double[],System.Double[],IM.Library.Delegates.FunctionDAtoD,System.Double)">
            <summary>
            Given a function f, and given a bracketing triplet of abscissas ax, bx, cx (such that bx is
            between ax and cx, and f(bx) is less than both f(ax) and f(cx)), this routine isolates
            the minimum to a fractional precision of about tol using Brent¡¯s method. The abscissa of
            the minimum is returned as Minimum, and the minimum function value is returned as brent, the
            returned function value.
            </summary>
        </member>
        <member name="M:IM.Library.Mathematics.NumericalRecipes.Mnbrak(System.Double,System.Double,IM.Library.Mathematics.NumericalRecipes.F1dimDelegate,System.Int32,System.Double[],System.Double[],IM.Library.Delegates.FunctionDAtoD)">
            <summary>
            Given a function func, and given distinct initial points ax and bx, this routine searches in
            the downhill direction (defined by the function as evaluated at the initial points) and returns
            new points ax, bx, cx that bracket a minimum of the function. Also returned are the function
            values at the three points, fa, fb, and fc.
            </summary>
        </member>
        <member name="M:IM.Library.Mathematics.NumericalRecipes.Amebsa(System.Double[][],System.Double[],System.Int32,System.Double[],System.Double,IM.Library.Delegates.FunctionDAtoD,System.Double,System.Double@,System.Int32@)">
            <summary>
            Multidimensional minimization of the function funk(x) where x[0..ndim-1] is a vector in
            ndim dimensions, by simulated annealing combined with the downhill simplex method of Nelder
            and Mead. The input matrix p[0..ndim,0..ndim-1] has ndim+1 rows, each an ndim-dimensional
            vector which is a vertex of the starting simplex. Also input are the following: the
            vector y[0..ndim], whose components must be pre-initialized to the values of funk evaluated
            at the ndim+1 vertices (rows) of p; ftol, the fractional convergence tolerance to be
            achieved in the function value for an early return; iter, and temptr. The routine makes iter
            function evaluations at an annealing temperature temptr, then returns. You should then decrease 
            temptr according to your annealing schedule, reset iter, and call the routine again
            (leaving other arguments unaltered between calls). If iter is returned with a positive value,
            then early convergence and return occurred. If you initialize yb to a very large value on the first
            call, then yb and pb[0..ndim-1] will subsequently return the best function value and point ever
            encountered (even if it is no longer a point in the simplex).
            </summary>
        </member>
        <member name="M:IM.Library.Mathematics.NumericalRecipes.Amotsa(System.Double[][],System.Double[],System.Double[],System.Int32,System.Double[],System.Double,IM.Library.Delegates.FunctionDAtoD,System.Int32,System.Double,System.Double,System.Double,System.Double@,System.Double@)">
            <summary> Extrapolates by a given factor through the face of a simplex across the high point, replacing the high point it if the new one is better
            </summary>
        </member>
        <member name="M:IM.Library.Mathematics.NumericalRecipes.Splie2(System.Single[],System.Single[],System.Single[0:,0:],System.Int32,System.Int32,System.Single[0:,0:])">
            <summary>
            Given an m by n tabulated function ya[0..m-1,0..n-1], and tabulated independent variables
            x2a[0..n-1], this routine constructs one-dimensional natural cubic splines of the rows of ya
            and returns the second-derivatives in the array y2a[0..m-1,0..n-1]. (The array x1a[0..m-1] is
            included in the argument list merely for consistency with routine splin2.)
            </summary>
        </member>
        <member name="M:IM.Library.Mathematics.NumericalRecipes.Spline(System.Single[],System.Single[],System.Int32,System.Single,System.Single,System.Single[])">
            <summary>
            Given arrays x[0..n-1] and y[0..n-1] containing a tabulated function, i.e., y_i = f(x_i), with
            x_0 less than x_1 less than ... less than x_n-1, and given values yp_0 and yp_n-1 for the first 
            derivative of the interpolating function at points 0 and n-1, respectively, this routine returns 
            an array y2[0..n-1] that contains the second derivatives of the interpolating function at the 
            tabulated points x_i. If yp_0 and/or yp_n-1 are equal to 1 ¡¿ 10^30 or larger, the routine is signaled 
            to set the corresponding boundary condition for a natural spline, with zero second derivative 
            on that boundary.
            </summary>
        </member>
        <member name="M:IM.Library.Mathematics.NumericalRecipes.Splin2(System.Single[],System.Single[],System.Single[0:,0:],System.Single[0:,0:],System.Int32,System.Int32,System.Single,System.Single)">
            <summary>
            Given x1a, x2a, ya, m, n as described in splie2 and y2a as produced by that routine, and
            given a desired interpolating point x1,x2; this routine returns an interpolated function value y
            by bicubic spline interpolation.
            </summary>
        </member>
        <member name="M:IM.Library.Mathematics.NumericalRecipes.Splint(System.Single[],System.Single[],System.Single[],System.Int32,System.Single)">
            <summary>
            Given the arrays xa[0..n-1] and ya[0..n-1], which tabulate a function (with the xai¡¯s in order),
            and given the array y2a[0..n-1], which is the output from spline above, and given a value of
            x, this routine returns a cubic-spline interpolated value y.
            </summary>
        </member>
        <member name="M:IM.Library.Mathematics.NumericalRecipes.Convlv(System.Double[],System.Int64,System.Double[],System.Int64,System.Int32,System.Double[]@)">
            <summary> Convolves or deconvolves a real-valued array with a response function.
            The answer is returned in the first n components of output.
            </summary>
            <remarks>a temporary array of size 2*n is created in this function</remarks>
            <param name="data">input data</param>
            <param name="n">size of the input data. MUST be a power of 2</param>
            <param name="respns">Response function (MUST be size n). The m/2 first elements are the impulse responses at positive times,
            while the m/2 next elements are the impulse responses at negative times.</param>
            <param name="m">number of values in the response function (must be an odd integer lower than n)</param>
            <param name="isign">1 for convolution, -1 for deconvolution</param>
            <param name="output">output data (must be given of size 2*n, but the result is formed of the n first elements)</param>
        </member>
        <member name="M:IM.Library.Mathematics.NumericalRecipes.Correl(System.Double[],System.Double[],System.Int64,System.Double[]@)">
            <summary> Computes the correlation of two real data sets data1 and data2 (including any user-supplied zero padding).
            The answer is returned as the first n points in output[0..2*n-1] stored in wrap-around order, i.e., correlations at
            increasingly negative lags are in output[n-1] on down to output[n/2], while correlations at increasingly positive lags
            are in output[0] (zero lag) on up to ans[n/2-1]. Sign convention of this routine: if data1 lags data2, i.e., is shifted
            to the right of it, then ans will show output peak at positive lags.
            </summary>
            <remarks>a temporary array of size 2*n is created in this function</remarks>
            <param name="data1">the first real-valued array to transform</param>
            <param name="data2">the second real-valued array to transform</param>
            <param name="n">size of the input data. MUST be a power of 2</param>
            <param name="output">output data (must be given of size 2*n, but the result is formed of the n first elements)</param>
        </member>
        <member name="M:IM.Library.Mathematics.NumericalRecipes.Four1(System.Double[],System.Int64,System.Int32)">
            <summary> 1-Dimensional discrete Fourier transform of a complex data array.
            The input data is replaced by its forward transform if isign is 1, or by nn times its inverse transform if isign is -1
            </summary>
            <param name="data">the complex data array to transform</param>
            <param name="nn">the number of complex values in the array, i.e. half the size of the array. MUST be a power of 2</param>
            <param name="isign">1 for forward transform, -1 for inverse transform</param>
        </member>
        <member name="M:IM.Library.Mathematics.NumericalRecipes.Fourn(System.Double[],System.Int64[],System.Int32,System.Int32)">
            <summary> N-dimensional discrete Fourier transform.
            </summary>
            <param name="data">real array of length twice the product of these lengths, in which the
            data are stored as in a multidimensional complex array: real and imaginary parts of each
            element are in consecutive locations, and the rightmost index of the array increases most
            rapidly as one proceeds along data.</param>
            <param name="nn">integer array containing the lengths of each dimension (number of complex values), which
            MUST all be powers of 2.</param>
            <param name="ndim">number of dimensions</param>
            <param name="isign">if 1, returns the ndim-dimensional discrete Fourier transform. If -1, returns the inverse
            transform times the product of the lengths of all dimensions </param>
        </member>
        <member name="M:IM.Library.Mathematics.NumericalRecipes.Realft(System.Double[],System.Int64,System.Int32)">
            <summary> Calculates the Fourier transform of a set of n real-valued data points (or n/2 times the inverse 
            of a complex array obtained by forward transform). For forward transform, the input data is replaced by the 
            positive frequency half of its complex Fourier transform.
            </summary>
            <param name="data">the input data array to transform</param>
            <param name="n">size of the input array. MUST be a power of 2</param>
            <param name="isign">1 for forward transform, -1 for inverse transform</param>
        </member>
        <member name="M:IM.Library.Mathematics.NumericalRecipes.Rlft3(System.Double[]@,System.Double[]@,System.Int64,System.Int64,System.Int64,System.Int32)">
            <summary> Given a three-dimensional real array data, returns the complex fast Fourier transform as two complex arrays:
            data contains the zero and positive frequency values of the third frequency
            component, while speq contains the Nyquist critical frequency values of the third frequency
            component. First (and second) frequency components are stored for zero, positive, and negative
            frequencies, in standard wrap-around order (see NR text).
            </summary>
            <param name="data">3D array containing the input data and replaced by a part of the output</param>
            <param name="speq">array of size[nn1*2*nn2] to receive the rest of the output</param>
            <param name="depth">Z dimension. MUST be a power of 2</param>
            <param name="height">Y dimension. MUST be a power of 2</param>
            <param name="width">X dimension. MUST be a power of 2</param>
            <param name="isign">1 for forward transform. -1 for nn1*nn2*nn3/2 times the inverse tranform</param>
        </member>
        <member name="M:IM.Library.Mathematics.NumericalRecipes.Twofft(System.Double[],System.Double[],System.Int64,System.Double[]@,System.Double[]@)">
            <summary> Simultaneous Fourier transform of 2 real-valued arrays data1 and data2.
            This is done by calling four1 function on a complex function were data1 represents real values and data2 imaginary values.
            </summary>
            <param name="data1">the first real-valued array to transform</param>
            <param name="data2">the second real-valued array to transform</param>
            <param name="fft1">the output transform of data1 (should be of size 2 * n)</param>
            <param name="fft2">the output transform of data2 (should be of size 2 * n)</param>
            <param name="n">the size of the input arrays. MUST be a power of 2</param>
        </member>
        <member name="M:IM.Library.Mathematics.NumericalRecipes.Gammln(System.Double)">
            <summary> Calculates ln(gamma(xx)), for xx>0
            </summary>
            <param name="xx">strictly positive value</param>
            <returns>ln(gamma(xx))</returns>
        </member>
        <member name="M:IM.Library.Mathematics.NumericalRecipes.Bessj0(System.Double)">
            <summary>Returns the Bessel function J0(x) for any real x
            </summary>
            <param name="x">a real number</param>
            <returns>J0(x)</returns>
        </member>
        <member name="M:IM.Library.Mathematics.NumericalRecipes.Bessj1(System.Double)">
            <summary>Returns the Bessel function J1(x) for any real x
            </summary>
            <param name="x">a real number</param>
            <returns>J1(x)</returns>
        </member>
        <member name="M:IM.Library.Mathematics.NumericalRecipes.Betacf(System.Double,System.Double,System.Double)">
            <summary>
            Used by betai: Evaluates continued fraction for incomplete beta function by modified Lentz¡¯s
            method (¡×5.2).
            </summary>
        </member>
        <member name="M:IM.Library.Mathematics.NumericalRecipes.Betai(System.Double,System.Double,System.Double)">
            <summary>
            Returns the incomplete beta function Ix(a, b).
            </summary>
        </member>
        <member name="P:IM.Library.Mathematics.NumericalRecipes.Y">
            <summary>Value reserved for use with the interpolation spline functions.
            </summary>
        </member>
        <member name="T:IM.Library.Mathematics.NumericalRecipes.Pwtset">
            <summary> Initialization class for pwt routine
            </summary>
        </member>
        <member name="M:IM.Library.Mathematics.NumericalRecipes.Pwtset.#ctor(System.Int32)">
            <summary> Initializes the Pwt routine by implementing the Daubechies wavelet filters with given coefficients.
            This routine must be called (once) before the first use of pwt.
            (For the case n=4, the specific routine daub4 is considerably faster than pwt.)
            </summary>
            <param name="n">the number of wavelet coefficients (4,12 or 20)</param>
        </member>
        <member name="P:IM.Library.Mathematics.NumericalRecipes.Pwtset.Ncof">
            <summary> Gets the number of coefficients
            </summary>
        </member>
        <member name="P:IM.Library.Mathematics.NumericalRecipes.Pwtset.Ioff">
            <summary> </summary>
        </member>
        <member name="P:IM.Library.Mathematics.NumericalRecipes.Pwtset.Joff">
            <summary> </summary>
        </member>
        <member name="P:IM.Library.Mathematics.NumericalRecipes.Pwtset.Cc">
            <summary> Gets the wavelet coefficients
            </summary>
        </member>
        <member name="P:IM.Library.Mathematics.NumericalRecipes.Pwtset.Cr">
            <summary> Gets the inverted and alterned wavelet coefficients
            </summary>
        </member>
        <member name="T:IM.Library.Mathematics.Matrix.QrDecomposition">
            <summary>
              QR decomposition for a rectangular matrix.
            </summary>
            <remarks>
              For an m-by-n matrix <c>A</c> with <c>m &gt;= n</c>, the QR decomposition is an m-by-n
              orthogonal matrix <c>Q</c> and an n-by-n upper triangular 
              matrix <c>R</c> so that <c>A = Q * R</c>.
              The QR decompostion always exists, even if the matrix does not have
              full rank, so the constructor will never fail.  The primary use of the
              QR decomposition is in the least squares solution of nonsquare systems
              of simultaneous linear equations.
              This will fail if <see cref="P:IM.Library.Mathematics.Matrix.QrDecomposition.FullRank"/> returns <see langword="false"/>.
            </remarks>
        </member>
        <member name="M:IM.Library.Mathematics.Matrix.QrDecomposition.#ctor(IM.Library.Mathematics.Matrix.Matrix)">
            <summary>Construct a QR decomposition.</summary>	
        </member>
        <member name="M:IM.Library.Mathematics.Matrix.QrDecomposition.Solve(IM.Library.Mathematics.Matrix.Matrix)">
            <summary>Least squares solution of <c>A * X = B</c></summary>
            <param name="value">Right-hand-side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>A matrix that minimized the two norm of <c>Q * R * X - B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix row dimensions must be the same.</exception>
            <exception cref="T:System.InvalidOperationException">Matrix is rank deficient.</exception>
        </member>
        <member name="P:IM.Library.Mathematics.Matrix.QrDecomposition.FullRank">
            <summary>Shows if the matrix <c>A</c> is of full rank.</summary>
            <value>The value is <see langword="true"/> if <c>R</c>, and hence <c>A</c>, has full rank.</value>
        </member>
        <member name="P:IM.Library.Mathematics.Matrix.QrDecomposition.UpperTriangularFactor">
            <summary>Returns the upper triangular factor <c>R</c>.</summary>
        </member>
        <member name="P:IM.Library.Mathematics.Matrix.QrDecomposition.OrthogonalFactor">
            <summary>Returns the orthogonal factor <c>Q</c>.</summary>
        </member>
        <member name="T:IM.Library.Mathematics.Fitting">
            <summary>
            Class defining Fitting operations
            </summary>
        </member>
        <member name="M:IM.Library.Mathematics.Fitting.#ctor">
            <summary>
            Constructor
            </summary>        
        </member>
        <member name="M:IM.Library.Mathematics.Fitting.LinearFit(System.Single[],System.Single@,System.Single@)">
            <summary> Linear Fit
            fit the equation Y=O+SX
            array is the Y value input
            X is assumed to be 0, 1, 2, 3, 4 etc...
            origin is O in Y=O+Sx
            slope is S in Y=O+Sx
            </summary>
        </member>
        <member name="M:IM.Library.Mathematics.Fitting.LinearFit(System.Single[],System.Single[],System.Single@,System.Single@)">
            <summary> Linear Fit
            fit the equation Y=O+SX
            arrayX is the X value input
            arrayY is the Y value input
            origin is O in Y=O+Sx
            slope is S in Y=O+Sx
            </summary>
        </member>
        <member name="M:IM.Library.Mathematics.Fitting.LinearFit(System.Single[],System.Single[],System.Single@,System.Single@,System.Single@,System.Single@)">
            <summary> Linear Fit
            fit the equation Y=O+SX
            arrayX is the X value input
            arrayY is the Y value input
            origin is O in Y=O+Sx
            slope is S in Y=O+Sx
            erroronorigin is the error on O in  Y=O+Sx
            erroronslope is the error on S in  Y=O+Sx 
            </summary>
        </member>
        <member name="M:IM.Library.Mathematics.Fitting.LinearFit(System.Single[],System.Single[],System.Single@,System.Single@,System.Single@,System.Single@,System.Single@)">
            <summary> Linear Fit
            fit the equation Y=O+SX
            arrayX is the X value input
            arrayY is the Y value input
            origin is O in Y=O+Sx
            slope is S in Y=O+Sx
            erroronorigin is the error on O in  Y=O+Sx
            erroronslope is the error on S in  Y=O+Sx 
            chisquare is the square of the sum of the errors on X and on Y
            </summary>
        </member>
        <member name="M:IM.Library.Mathematics.Fitting.LinearFit(System.Single[],System.Single[],System.Single[],System.Single@,System.Single@)">
            <summary> Linear Fit
            fit the equation Y=O+SX
            arrayX is the X value input
            arrayY is the Y value input
            errorX inputs the error bars on each arrayX value 
            errorY inputs the error bars on each arrayY value 
            origin is O in Y=O+Sx
            slope is S in Y=O+Sx
            </summary>
        </member>
        <member name="M:IM.Library.Mathematics.Fitting.EllipseFit2D(System.Collections.Generic.List{System.Single[]},System.Single[]@,System.Single@)">
            <summary>
            [2D ONLY] Compute Coefficients for 2D Ellipse Fitting Problem from Given Points Data<para/>
            Input  : (1) points - List of float[2] (float[0] = x, float[1] = y)
                         These points must not be co-liner
            Output : (1) coeff - float[6] of coefficients [a, b, h, p, q, d] Such That
                         a*(x^2) + b*(y^2) + h*(xy) + p*(x) + q*(y) + d = 0
                     (2) error - average error between given data points and estimated ellipse
                     (3) return - true if fitting process succeeded, false if not
            
            Reference : Direct Least Square Fitting of Ellipses, A. fitzgibbon, M. Pilu, R. Fisher,
                        Tern Analysis and Machine Intelligence, 1999
            </summary>
            <param name="points">input - data points</param>
            <param name="coeff">output - coefficients</param>
            <param name="error">output - average error</param>
        </member>
        <member name="M:IM.Library.Mathematics.Fitting.EllipseFit3D(System.Collections.Generic.List{System.Single[]},System.Single[]@,System.Single@)">
            <summary>
            [3D ONLY] Compute Coefficients for 3D Ellipse Fitting Problem from Given Points Data<para/>
            Input  : (1) points - List of float[3] (float[0] = x, float[1] = y, float[2] = z)
                         These points must not be co-planar
            Output : (1) coeff - float[10] of coefficients [a, b, c, f, g, h, p, q, r, d] Such That
                         a*(x^2) + b*(y^2) + c*(z^2) + f*(yz) + g*(xz) + h*(xy) + p*(x) + q*(y) + r*(z) + d = 0
                     (2) error - average error between given data points and estimated ellipse
                     (3) return - true if fitting process succeeded, false if not
            
            Reference : Least Square Ellipsoid Specific Fitting, Q. Li, J. Griffiths,
                        Proceedings of the Geometric Modeling and Processing, 2004
            </summary>
            <param name="points">input - data points</param>
            <param name="coeff">output - coefficients</param>
            <param name="error">output - average error</param>
        </member>
        <member name="M:IM.Library.Mathematics.Fitting.FillFittedEllipse(System.Single[],IM.Imaging.Image3D@,System.Int32)">
            <summary>
            Fill inside area of ellipse given by coefficients
            </summary>
            <param name="coeff">ellipse coefficients - float[6] : 2D ellipse, float[10] : 3D ellipse</param>
            <param name="output">ellipse-filled image3D</param>
            <param name="band">band to draw</param>
        </member>
        <member name="M:IM.Library.Mathematics.Fitting.CircleFit2D(System.Collections.Generic.List{System.Single[]},System.Single[]@,System.Single@)">
            <summary>
            [2D ONLY] Compute Coefficients for 2D Circle Fitting Problem from Given Points Data<para/>
            Input  : (1) points - List of float[2] (float[0] = x, float[1] = y)
                         These points must not be co-liner
            Output : (1) coeff - float[3] of coefficients [centerX, centerY, radius] Such That
                         (x - centerX)^2 + (y - centerY)^2 - (radius)^2 = 0
                     (2) error - average error between given data points and estimated ellipse
                     (3) return - true if fitting process succeeded, false if not
            </summary>
            <param name="points">input - data points</param>
            <param name="coeff">output - coefficients</param>
            <param name="error">output - average error</param>
        </member>
        <member name="M:IM.Library.Mathematics.Fitting.CircleFit3D(System.Collections.Generic.List{System.Single[]},System.Single[]@,System.Single@)">
            <summary>
            [3D ONLY] Compute Coefficients for 3D Circle Fitting Problem from Given Points Data<para/>
            Input  : (1) points - List of float[3] (float[0] = x, float[1] = y, float[2] = z)
                         These points must not be co-planar
            Output : (1) coeff - float[4] of coefficients [centarX, centerY, centerZ, radius] Such That
                         (x - centerX)^2 + (y - centerY)^2 + (z - centerZ)^2 - (radius)^2 = 0
                     (2) error - average error between given data points and estimated ellipse
                     (3) return - true if fitting process succeeded, false if not
            
            Reference : Least Square Ellipsoid Specific Fitting, Q. Li, J. Griffiths,
                        Proceedings of the Geometric Modeling and Processing, 2004
            </summary>
            <param name="points">input - data points</param>
            <param name="coeff">output - coefficients</param>
            <param name="error">output - average error</param>
        </member>
        <member name="M:IM.Library.Mathematics.Fitting.FillFittedCircle(System.Single[],IM.Imaging.Image3D@,System.Int32)">
            <summary>
            Fill inside area of ellipse given by coefficients
            </summary>
            <param name="coeff">ellipse coefficients - float[3] : 2D ellipse, float[4] : 3D ellipse</param>
            <param name="output">ellipse-filled image3D</param>
            <param name="band">band to draw</param>
        </member>
        <member name="T:IM.Library.Mathematics.Fitting.functionofx">
            <summary> NonLinear Fit
            Denis Fenistein
            fit the equation Y=f(X, parameters[])
            Nparameters is the number of fitted parameters
            parameters is the float[Nparameters] containing the values of the fitting parameters
            functionof x contains for each x its value Y=f(x, parameters[])
            derivativeoffx contains for each x all of its derivative values value Y=df(x, parameters[])/dparameter[ii]
            </summary>
        </member>
        <member name="T:IM.Library.Mathematics.Matrix.EigenvalueDecomposition">
            <summary>
            Determines the eigenvalues and eigenvectors of a real square matrix.
            </summary>
            <remarks>
            If <c>A</c> is symmetric, then <c>A = V * D * V'</c> and <c>A = V * V'</c>
            where the eigenvalue matrix <c>D</c> is diagonal and the eigenvector matrix <c>V</c> is orthogonal.
            If <c>A</c> is not symmetric, the eigenvalue matrix <c>D</c> is block diagonal
            with the real eigenvalues in 1-by-1 blocks and any complex eigenvalues,
            <c>lambda+i*mu</c>, in 2-by-2 blocks, <c>[lambda, mu; -mu, lambda]</c>.
            The columns of <c>V</c> represent the eigenvectors in the sense that <c>A * V = V * D</c>.
            The matrix V may be badly conditioned, or even singular, so the validity of the equation
            <c>A=V*D*inverse(V)</c> depends upon the condition of <c>V</c>.
            </remarks>
        </member>
        <member name="M:IM.Library.Mathematics.Matrix.EigenvalueDecomposition.#ctor(IM.Library.Mathematics.Matrix.Matrix)">
            <summary>Construct an eigenvalue decomposition.</summary>
        </member>
        <member name="P:IM.Library.Mathematics.Matrix.EigenvalueDecomposition.RealEigenvalues">
            <summary>Returns the real parts of the eigenvalues.</summary>
        </member>
        <member name="P:IM.Library.Mathematics.Matrix.EigenvalueDecomposition.ImaginaryEigenvalues">
            <summary>Returns the imaginary parts of the eigenvalues.</summary>	
        </member>
        <member name="P:IM.Library.Mathematics.Matrix.EigenvalueDecomposition.EigenvectorMatrix">
            <summary>Returns the eigenvector matrix.</summary>
        </member>
        <member name="P:IM.Library.Mathematics.Matrix.EigenvalueDecomposition.DiagonalMatrix">
            <summary>Returns the block diagonal eigenvalue matrix.</summary>
        </member>
        <member name="T:IM.Library.Mathematics.Matrix.PCA">
            <summary>
            Principal Components Analysis
            </summary>
        </member>
        <member name="F:IM.Library.Mathematics.Matrix.PCA.fMeans">
            <summary>
            Store original Data avg values for further projection (data as float)
            </summary>
        </member>
        <member name="F:IM.Library.Mathematics.Matrix.PCA.dMeans">
            <summary>
            Store original Data avg values for further projection (data as double)
            </summary>
        </member>
        <member name="M:IM.Library.Mathematics.Matrix.PCA.#ctor(System.Double[][])">
            <summary>
            Principal Components Analysis for data of type double
            </summary>
            <param name="dData">Data [][]</param>
        </member>
        <member name="M:IM.Library.Mathematics.Matrix.PCA.#ctor(System.Double[][],System.Boolean)">
            <summary>
            Principal Components Analysis for data of type double
            </summary>
            <param name="dData">Data [][]</param>
            <param name="isNormalize">ture to use covarance matrix, false to use correlation matrix</param>
        </member>
        <member name="M:IM.Library.Mathematics.Matrix.PCA.covMat(System.Single[][])">
            <summary>
            Computes the covariance matrix of a dataset
            </summary>
            <param name="data">dataset, must be rectangular</param>
            <returns></returns>
        </member>
        <member name="M:IM.Library.Mathematics.Matrix.PCA.corrMat(System.Single[][])">
            <summary>
            Computes the correlation matrix of a dataset
            </summary>
            <param name="data">dataset, must be rectangular</param>
            <returns></returns>
        </member>
        <member name="M:IM.Library.Mathematics.Matrix.PCA.project(System.Single[][])">
            <summary>
            projects the data in the current PC coordinate system
            </summary>
            <param name="data">input data (row: features, col: individuals)</param>
            <returns>projected data</returns>
        </member>
        <member name="M:IM.Library.Mathematics.Matrix.PCA.project(System.Double[][])">
            <summary>
            projects the data in the current PC coordinate system
            </summary>
            <param name="data">input data (row: features, col: individuals)</param>
            <returns>projected data</returns>
        </member>
        <member name="T:IM.Library.Mathematics.Matrix.LuDecomposition">
            <summary>
              LU decomposition of a rectangular matrix.
            </summary>
            <remarks>
              For an m-by-n matrix <c>A</c> with m &gt;= n, the LU decomposition is an m-by-n
              unit lower triangular matrix <c>L</c>, an n-by-n upper triangular matrix <c>U</c>,
              and a permutation vector <c>piv</c> of length m so that <c>A(piv)=L*U</c>.
              If m &lt; n, then <c>L</c> is m-by-m and <c>U</c> is m-by-n.
              The LU decompostion with pivoting always exists, even if the matrix is
              singular, so the constructor will never fail.  The primary use of the
              LU decomposition is in the solution of square systems of simultaneous
              linear equations. This will fail if <see cref="P:IM.Library.Mathematics.Matrix.LuDecomposition.NonSingular"/> returns <see langword="false"/>.
            </remarks>
        </member>
        <member name="M:IM.Library.Mathematics.Matrix.LuDecomposition.#ctor(IM.Library.Mathematics.Matrix.Matrix)">
            <summary>Construct a LU decomposition.</summary>	
        </member>
        <member name="M:IM.Library.Mathematics.Matrix.LuDecomposition.Solve(IM.Library.Mathematics.Matrix.Matrix)">
            <summary>Solves a set of equation systems of type <c>A * X = B</c>.</summary>
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * U * X = B</c>.</returns>
        </member>
        <member name="P:IM.Library.Mathematics.Matrix.LuDecomposition.NonSingular">
            <summary>Returns if the matrix is non-singular.</summary>
        </member>
        <member name="P:IM.Library.Mathematics.Matrix.LuDecomposition.Determinant">
            <summary>Returns the determinant of the matrix.</summary>
        </member>
        <member name="P:IM.Library.Mathematics.Matrix.LuDecomposition.LowerTriangularFactor">
            <summary>Returns the lower triangular factor <c>L</c> with <c>A=LU</c>.</summary>
        </member>
        <member name="P:IM.Library.Mathematics.Matrix.LuDecomposition.UpperTriangularFactor">
            <summary>Returns the lower triangular factor <c>L</c> with <c>A=LU</c>.</summary>
        </member>
        <member name="P:IM.Library.Mathematics.Matrix.LuDecomposition.PivotPermutationVector">
            <summary>Returns the pivot permuation vector.</summary>
        </member>
        <member name="T:IM.Library.Mathematics.Matrix.CholeskyDecomposition">
            <summary>
            	Cholesky Decomposition of a symmetric, positive definite matrix.
            </summary>
            <remarks>
            	For a symmetric, positive definite matrix <c>A</c>, the Cholesky decomposition is a
            	lower triangular matrix <c>L</c> so that <c>A = L * L'</c>.
            	If the matrix is not symmetric or positive definite, the constructor returns a partial 
            	decomposition and sets two internal variables that can be queried using the
            	<see cref="P:IM.Library.Mathematics.Matrix.CholeskyDecomposition.Symmetric"/> and <see cref="P:IM.Library.Mathematics.Matrix.CholeskyDecomposition.PositiveDefinite"/> properties.
            </remarks>
        </member>
        <member name="M:IM.Library.Mathematics.Matrix.CholeskyDecomposition.#ctor(IM.Library.Mathematics.Matrix.Matrix)">
            <summary>Construct a Cholesky Decomposition.</summary>
        </member>
        <member name="M:IM.Library.Mathematics.Matrix.CholeskyDecomposition.Solve(IM.Library.Mathematics.Matrix.Matrix)">
            <summary>Solves a set of equation systems of type <c>A * X = B</c>.</summary>
            <param name="value">Right hand side matrix with as many rows as <c>A</c> and any number of columns.</param>
            <returns>Matrix <c>X</c> so that <c>L * L' * X = B</c>.</returns>
            <exception cref="T:System.ArgumentException">Matrix dimensions do not match.</exception>
            <exception cref="T:System.InvalidOperationException">Matrix is not symmetrix and positive definite.</exception>
        </member>
        <member name="P:IM.Library.Mathematics.Matrix.CholeskyDecomposition.Symmetric">
            <summary>Returns <see langword="true"/> if the matrix is symmetric.</summary>
        </member>
        <member name="P:IM.Library.Mathematics.Matrix.CholeskyDecomposition.PositiveDefinite">
            <summary>Returns <see langword="true"/> if the matrix is positive definite.</summary>
        </member>
        <member name="P:IM.Library.Mathematics.Matrix.CholeskyDecomposition.LeftTriangularFactor">
            <summary>Returns the left triangular factor <c>L</c> so that <c>A = L * L'</c>.</summary>
        </member>
        <member name="T:IM.Library.Filtering.PredefinedKernel">
            <summary> Enumeration of default kernels available</summary>
        </member>
        <member name="F:IM.Library.Filtering.PredefinedKernel.Gradient">
            <summary>A 3x1 gradient kernel using central differences</summary>
        </member>
        <member name="F:IM.Library.Filtering.PredefinedKernel.Laplacian2D">
            <summary>A 3x3 Laplacian kernel</summary>
        </member>
        <member name="F:IM.Library.Filtering.PredefinedKernel.Prewitt2D_X">
            <summary>A 3x3 horizontal Prewitt kernel</summary>
        </member>
        <member name="F:IM.Library.Filtering.PredefinedKernel.Prewitt2D_Y">
            <summary>A 3x3 vertical Prewitt kernel</summary>
        </member>
        <member name="F:IM.Library.Filtering.PredefinedKernel.Sobel2D_X">
            <summary>A 3x3 horizontal Sobel kernel</summary>
        </member>
        <member name="F:IM.Library.Filtering.PredefinedKernel.Sobel2D_Y">
            <summary>A 3x3 vertical Sobel kernel</summary>
        </member>
        <member name="F:IM.Library.Filtering.PredefinedKernel.Gaussian">
            <summary>A 3x1 gaussian kernel (mean 0, std 0.5)</summary>
        </member>
        <member name="F:IM.Library.Filtering.PredefinedKernel.NorthKirsch">
            <summary>A 3x3 oriented north Kirsh kernel</summary>
        </member>
        <member name="F:IM.Library.Filtering.PredefinedKernel.NorthEastKirsch">
            <summary>A 3x3 oriented north-east Kirsh kernel</summary>
        </member>
        <member name="F:IM.Library.Filtering.PredefinedKernel.EastKirsch">
            <summary>A 3x3 oriented east Kirsh kernel</summary>
        </member>
        <member name="F:IM.Library.Filtering.PredefinedKernel.SouthEastKirsch">
            <summary>A 3x3 oriented south-east Kirsh kernel</summary>
        </member>
        <member name="F:IM.Library.Filtering.PredefinedKernel.SouthKirsch">
            <summary>A 3x3 oriented south Kirsh kernel</summary>
        </member>
        <member name="F:IM.Library.Filtering.PredefinedKernel.SouthWestKirsch">
            <summary>A 3x3 oriented south-west Kirsh kernel</summary>
        </member>
        <member name="F:IM.Library.Filtering.PredefinedKernel.WestKirsch">
            <summary>A 3x3 oriented west Kirsh kernel</summary>
        </member>
        <member name="F:IM.Library.Filtering.PredefinedKernel.NorthWestKirsch">
            <summary>A 3x3 oriented north-west Kirsh kernel</summary>
        </member>
        <member name="T:IM.Library.Filtering.KernelMaker">
            <summary> Utility class to create kernels (compatible with the convolution class)</summary>
            <list type="table">
            <listheader> <term>Version</term> <description>Changes</description> </listheader>
            <item> <term>3.0</term> <description>(AG,AD) Redesigned class again, a kernel is now an Image3D, convolution methods redesigned accordingly</description> </item>
            <item> <term>2.0</term> <description>(AD) Redesigned class, kernel types and calling methods. Should be much simpler to use</description> </item>
            <item> <term>1.1</term> <description>(AD) added "Gradient*" kernels</description> </item>
            <item> <term>1.0</term> <description>(AD) first operational build, creates "Custom*", "GaussianDefault*" and "GaussianBySigmas*" kernels</description> </item>
            </list>
        </member>
        <member name="M:IM.Library.Filtering.KernelMaker.#ctor">
            <summary> Creates a new instance of the KernelMaker utility
            </summary>
        </member>
        <member name="M:IM.Library.Filtering.KernelMaker.MakePredefinedKernel(IM.Library.Filtering.PredefinedKernel)">
            <summary> Creates a predefined kernel of chosen type
            </summary>
            <param name="type">the kernel to create</param>
            <seealso cref="T:IM.Library.Filtering.PredefinedKernel"/>
            <returns></returns>
        </member>
        <member name="M:IM.Library.Filtering.KernelMaker.MakeGradientKernel">
            <summary> Build a gradient kernel using central differences
            </summary>
            <returns>a 1x3 gradient kernel</returns>
        </member>
        <member name="M:IM.Library.Filtering.KernelMaker.Make2DLaplacianKernel">
            <summary> Build a 2D Lapacian kernel
            </summary>
            <returns></returns>
        </member>
        <member name="M:IM.Library.Filtering.KernelMaker.Make2DVerticalPrewittKernel">
            <summary> Build a 2D Horizontal Prewitt kernel
            </summary>
            <returns></returns>
        </member>
        <member name="M:IM.Library.Filtering.KernelMaker.Make2DHorizontalPrewittKernel">
            <summary> Build a 2D Vertical Prewitt kernel
            </summary>
            <returns></returns>
        </member>
        <member name="M:IM.Library.Filtering.KernelMaker.Make2DVerticalSobelKernel">
            <summary> Build a 2D Horizontal Sobel kernel
            </summary>
            <returns></returns>
        </member>
        <member name="M:IM.Library.Filtering.KernelMaker.Make2DHorizontalSobelKernel">
            <summary> Build a 2D Vertical Sobel kernel
            </summary>
            <returns></returns>
        </member>
        <member name="M:IM.Library.Filtering.KernelMaker.MakeGaussianKernel">
            <summary> Creates a normalized 1D Gaussian kernel with default values (variance 0.5)
            </summary>
            <returns>The newly constructed kernel</returns>
        </member>
        <member name="M:IM.Library.Filtering.KernelMaker.Make2DEpanechnikovKernel(System.Int32)">
            <summary>
            
            </summary>
            <param name="Radius"></param>
            <returns></returns>
        </member>
        <member name="M:IM.Library.Filtering.KernelMaker.MakeGaussianKernel(System.Single)">
            <summary> Creates a 1D Gaussian kernel with given standard deviation (kernel size is automatically computed)
            </summary>
            <param name="sigma">The standard deviation</param>
            <returns>The newly constructed kernel</returns>
            <remarks>The kernel size in automatically computing knowing that a Gaussian distribution 
            is almost zero more than about three standard deviation from the mean</remarks>
        </member>
        <member name="M:IM.Library.Filtering.KernelMaker.Make2DGaborKernel(System.Single,System.Single,System.Single,System.Boolean)">
            <summary>Creates a 2D Gaussian kernel with given standard deviations (kernel size is automatically computed)</summary>
            <param name="sigma">The standard deviation</param>
            <param name="k_x">kx</param>
            <param name="k_y">ky</param>
            <param name="IsSymmetric">symetric or antisymmetric component</param>
            <returns>The newly constructed kernel</returns>
            <remarks>The kernel size in automatically computing knowing that output Gaussian distribution 
            is almost zero more than about three standard deviation from the mean</remarks>
        </member>
        <member name="M:IM.Library.Filtering.KernelMaker.Make2DGaborKernel(System.Single,System.Single,System.Single,System.Single,System.Boolean)">
            <summary>Creates a 2D Gabor kernel with given standard deviations (kernel size is automatically computed)</summary>
            <param name="sigma_x">Variance along x-axis</param>
            <param name="sigma_y">Variance along y-axis</param>
            <param name="f">frequency of the sinusoidal function</param>
            <param name="Teta">Orientation of the gabor filter</param>
            <param name="IsSymmetric">Symmetric or Anti-symmetric filter</param>
            <returns>The newly constructed kernel</returns>
            <remarks>The kernel size in automatically computing knowing that output Gaussian distribution 
            is almost zero more than about three standard deviation from the mean</remarks>
        </member>
        <member name="M:IM.Library.Filtering.KernelMaker.Make2DGaborKernel(IM.Imaging.Image3D@,System.Single,System.Single,System.Single,System.Single,System.Boolean)">
            <summary>Creates a 2D Gabor kernel with given standard deviations</summary>
            <param name="output">Output Image</param>
            <param name="sigma_x">Variance along x-axis</param>
            <param name="sigma_y">Variance along y-axis</param>
            <param name="f">frequency of the sinusoidal function</param>
            <param name="Teta">Orientation of the gabor filter</param>
            <param name="IsSymmetric">Symmetric or Anti-symmetric filter</param>
            <returns>The newly constructed kernel</returns>
            <remarks>The kernel size in automatically computing knowing that output Gaussian distribution 
            is almost zero more than about three standard deviation from the mean</remarks>
        </member>
        <member name="M:IM.Library.Filtering.KernelMaker.Make2DGaussianKernel(System.Single,System.Single,System.Single)">
            <summary>Creates a 2D Gaussian kernel with given standard deviations (kernel size is automatically computed)</summary>
            <param name="sigma_x">Variance along x-axis</param>
            <param name="sigma_y">Variance along y-axis</param>
            <param name="Teta">Orientation of the Gaussian filter</param>
            <returns>The newly constructed kernel</returns>
            <remarks>The kernel size in automatically computing knowing that output Gaussian distribution 
            is almost zero more than about three standard deviation from the mean</remarks>
        </member>
        <member name="M:IM.Library.Filtering.KernelMaker.MakeLaplacianOfGaussianKernel2D(System.Single)">
            <summary> Creates a 2D Laplacian of Gaussian (LOG) kernel with given standard deviation (kernel size is automatically computed)
            </summary>
            <param name="sigma">The standard deviation</param>
            <returns>The newly constructed kernel</returns>
            <remarks>The kernel size in automatically computing knowing that a Gaussian distribution 
            is almost zero more than about three standard deviation from the mean</remarks>
        </member>
        <member name="M:IM.Library.Filtering.KernelMaker.MakeGaussianKernel(System.Int32,System.Single)">
            <summary> Creates a 1D Gaussian kernel with given standard deviation and radius
            </summary>
            <param name="radius">the kernel radius</param>
            <param name="sigma">the standard deviation of the gaussian</param>
            <returns>a 1D kernel of size (2*radius+1)</returns>
        </member>
        <member name="M:IM.Library.Filtering.KernelMaker.Normalize(IM.Imaging.Image3D)">
            <summary> Normalize a kernel to 1
            </summary>
            <param name="kernel">the kernel to normalize</param>
        </member>
        <member name="T:IM.Library.Mathematics.Curvature">
            <summary> Class defining curvature operations. </summary>
            <list type="table">
            <listheader> <term>Version</term> <description>Changes</description> </listheader>
            <item><term>2.3</term><description>(BL) added thread handling class, multithreaded implementation of  ComputeGradientNdPoint(FunctionDAtoD, double[], double)</description></item>
            <item><term>2.2</term><description>(DF) addition of 2d centered intensity curvature </description></item>
            <item><term>2.2</term><description>(ED) 3d intensity curvature (double gradient)</description></item>
            <item><term>2.1</term><description>(AD) 2D routines recoded faster </description></item>
            <item><term>2.0</term><description>(AD) migrated to object framework </description></item>
            <item><term>1.3</term><description>(ED) modification of intensity curvature function for a 3d float array </description></item>
            <item><term>1.2</term><description>(TD) intensity curvature for a 2d float array</description></item>
            <item><term>1.1</term><description>(ED) intensity curvature for a list of point</description></item>
            <item><term>1.0</term> <description>(ED) first operational build</description> </item>
            </list>
        </member>
        <member name="M:IM.Library.Mathematics.Curvature.#ctor">
            <summary> Creates a new instance of the Curvature Toolbox
            </summary>
        </member>
        <member name="M:IM.Library.Mathematics.Curvature.Compute3DHessianEigenvaluePoint(IM.Imaging.Image3D,System.Int32,System.Int32[],System.Single[][],System.Single)">
            <summary> Compute 3d eigenvalues of the Hessian matrix (Mirror conditions gradient) </summary>
            <param name="input">The input image</param>
            <param name="inputBand">the input band</param>
            <param name="pointsIndexes">The list of indexes of points where to compute the curvature</param>
            <param name="pointsCurvature">The output list of curvatures computed at the given points (dim [3][nb point])</param>
            <param name="weightz">ratio z/xy</param>    
        </member>
        <member name="M:IM.Library.Mathematics.Curvature.Compute3DHessianEigenvalue(IM.Imaging.Image3D,System.Int32,System.Single,IM.Imaging.Image3D)">
            <summary> Compute the 3 eigenvalues of the hessian matirx for each point of the input image ( Mirror conditions gradient) </summary>
            <param name="input">The input image</param>
            <param name="inputBand">the input band</param>
            <param name="output">3 channel output image ,contains on each channel one eigenvalue (0-> ev in x, 1-> ev in y, 2->ev in z</param>
            <param name="weightz">ratio z/xy</param>    
        </member>
        <member name="M:IM.Library.Mathematics.Curvature.ComputeGaussianCurvatureDoubleGradient3d(IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D,System.Int32,System.Single)">
            <summary> Compute 3d intensity curvature (double gradient) (defined by det(H(x,y,z))) on one band of an image with Mirror conditions gradient </summary>
            <param name="input">The input image</param>
            <param name="inputBand">the input band</param>
            <param name="output">The output image</param>
            <param name="outputBand">the ouput band</param>
            <param name="weightz">ratio z/xy</param>    
        </member>
        <member name="M:IM.Library.Mathematics.Curvature.ComputeMeanCurvatureDoubleGradient3d(IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D,System.Int32,System.Single)">
            <summary> Compute 3d intensity curvature (double gradient) (defined by trace(H(x,y,z))) on one band of an image with Mirror conditions gradient </summary>
            <param name="input">The input image</param>
            <param name="inputBand">the input band</param>
            <param name="output">The output image</param>
            <param name="outputBand">the ouput band</param>
            <param name="weightz">ratio z/xy</param>    
        </member>
        <member name="M:IM.Library.Mathematics.Curvature.ComputeGaussianCurvatureDoubleGradient3dPoint(IM.Imaging.Image3D,System.Int32,System.Int32[],System.Single[],System.Single)">
            <summary> Compute 3d intensity curvature (double gradient) (defined by det(H(x,y,z))) on one band of an image with Mirror conditions gradient </summary>
            <param name="input">The input image</param>
            <param name="inputBand">the input band</param>
            <param name="pointsIndexes">The list of indexes of points where to compute the curvature</param>
            <param name="pointsCurvature">The output list of curvatures computed at the given points</param>
            <param name="weightz">ratio z/xy</param>    
        </member>
        <member name="M:IM.Library.Mathematics.Curvature.ComputeMeanCurvatureDoubleGradient3dPoint(IM.Imaging.Image3D,System.Int32,System.Int32[],System.Single[],System.Single)">
            <summary> Compute 3d intensity curvature (double gradient) (defined by trace(H(x,y,z))) on one band of an image with Mirror conditions gradient </summary>
            <param name="input">The input image</param>
            <param name="inputBand">the input band</param>
            <param name="pointsIndexes">The list of indexes of points where to compute the curvature</param>
            <param name="pointsCurvature">The output list of curvatures computed at the given points</param>
            <param name="weightz">ratio z/xy</param>    
        </member>
        <member name="M:IM.Library.Mathematics.Curvature.ComputeCurvatureIntensity3d(IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D,System.Int32,System.Single)">
            <summary> Compute 3d intensity curvature  (defined by det(H(x,y,z))) on one band of an image with Mirror conditions gradient </summary>
            <param name="input">The input image</param>
            <param name="inputBand">the input band</param>
            <param name="output">The output image</param>
            <param name="outputBand">the ouput band</param>
            <param name="weightz">ratio z/xy</param>    
        </member>
        <member name="M:IM.Library.Mathematics.Curvature.ComputeCurvatureIntensity3dPoint(IM.Imaging.Image3D,System.Int32,System.Int32[],System.Single[],System.Single)">
            <summary> Compute 3d intensity curvature  (defined by det(H(x,y,z))) on a list of points with mirror boundary conditions </summary>
            <param name="image">The input image</param>
            <param name="inputBand">The input band</param>
            <param name="pointsIndexes">The list of indexes of points where to compute the curvature</param>
            <param name="pointsCurvature">The output list of curvatures computed at the given points</param>
            <param name="weightz">ratio z/xy</param>
        </member>
        <member name="M:IM.Library.Mathematics.Curvature.ComputeGradientNdPoint(IM.Library.Delegates.FunctionDAtoD,System.Double[],System.Double)">
            <summary> Computes the gradient vector for a specific point in an N dimensions space
            </summary>
            <param name="func">Function to be derivated</param>
            <param name="ParameterValues">Point position in the N-d space </param>
            <param name="GradStep">Step for the gradient evaluation</param>
        </member>
        <member name="M:IM.Library.Mathematics.Curvature.ComputeGradientNdPoint(IM.Library.Delegates.FunctionFAtoF,System.Single[],System.Single[],System.Single[],System.Single[],System.Single)">
            <summary> Computes the gradient vector for a specific point in an N dimensions space
            </summary>
            <param name="func">Function to be derivated</param>
            <param name="LimitMin">Minimum limits of the function</param>
            <param name="LimitMax">Maximum limits of the function</param>
            <param name="ParameterValues">Point position in the N-d space </param>
            <param name="GradientVector">Gradient vector to be computed</param>
            <param name="GradStep">Step for the gradient evaluation</param>
        </member>
        <member name="M:IM.Library.Mathematics.Curvature.ComputeGradientNdPoint(IM.Library.Delegates.FunctionDAtoD,System.Double[],System.Double[],System.Double[],System.Double[],System.Double)">
            <summary> Computes the gradient vector for a specific point in an N dimensions space
            </summary>
            <param name="func">Function to be derivated</param>
            <param name="LimitMin">Minimum limits of the function</param>
            <param name="LimitMax">Maximum limits of the function</param>
            <param name="ParameterValues">Point position in the N-d space </param>
            <param name="GradientVector">Gradient vector to be computed</param>
            <param name="GradStep">Step for the gradient evaluation</param>
        </member>
        <member name="M:IM.Library.Mathematics.Curvature.ComputeMeanCurvatureIntensity2d(IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D,System.Int32)">
            <summary> Computes the 2D intensity mean curvature  (defined by 1/2*Trace(H)) on one band of an image with Mirror conditions </summary>
            <param name="input">The input image</param>
            <param name="inputBand">the input band</param>
            <param name="output">The output image</param>
            <param name="outputBand">the ouput band</param>
        </member>
        <member name="M:IM.Library.Mathematics.Curvature.ComputeMeanCurvatureIntensity2dFor1Point(IM.Imaging.Image3D,System.Int32,System.Int32,System.Int32)">
            <summary> Computes the 2D intensity mean curvature  (defined by 1/2*Trace(H)) on one band of an image with Mirror conditions </summary>
            <param name="input">The input image</param>
            <param name="inputBand">the input band</param>
            <param name="PosX">The point's X coordinate</param>
            <param name="PosY">the point's Y coordinate</param>
        </member>
        <member name="M:IM.Library.Mathematics.Curvature.ComputeCurvatureIntensity2d(IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D,System.Int32)">
            <summary> Computes the 2D intensity curvature  (defined by det(H(x,y))) on one band of an image with Mirror conditions </summary>
            <param name="input">The input image</param>
            <param name="inputBand">the input band</param>
            <param name="output">The output image</param>
            <param name="outputBand">the ouput band</param>
        </member>
        <member name="M:IM.Library.Mathematics.Curvature.ComputeCurvatureIntensity2d(System.Single[],System.Int32,System.Single[])">
            <summary> Computes the 2D curvature
            </summary>
            <param name="input">the input image</param>
            <param name="spicx">the input image width</param>
            <param name="output">the output image</param>
        </member>
        <member name="M:IM.Library.Mathematics.Curvature.ComputeCenteredCurvatureIntensity2d(System.Single[],System.Int32,System.Single[])">
            <summary> Computes the centered intensity curvature in 2D
            </summary>
            <param name="input">the input image</param>
            <param name="spicx">the image width</param>
            <param name="output">the output image</param>
        </member>
        <member name="M:IM.Library.Mathematics.Curvature.ComputeCenteredCurvatureIntensity2d(IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D,System.Int32)">
            <summary> Computes the centered intensity curvature in 2D
            </summary>
            <param name="input">the input image</param>
            <param name="inputBand">the input image band</param>
            <param name="output">the output image</param>
            <param name="outputBand">the output image band</param>
        </member>
        <member name="M:IM.Library.Mathematics.Curvature.ComputeCenteredMeanCurvatureIntensity2d(IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D,System.Int32)">
            <summary> Computes the centered mean intensity curvature in 2D
            </summary>
            <param name="input">the input image</param>
            <param name="inputBand">the input image band</param>
            <param name="output">the output image</param>
            <param name="outputBand">the output image band</param>
        </member>
        <member name="M:IM.Library.Mathematics.Curvature.ComputeCenteredMeanCurvatureIntensity2d(System.Single[],System.Int32,System.Single[])">
            <summary> Computes the centered mean intensity curvature in 2D
            </summary>
            <param name="input">the input image</param>
            <param name="spicx">the image width</param>
            <param name="output">the output image</param>
        </member>
        <member name="M:IM.Library.Mathematics.Curvature.ComputeCurvatureMeanIntensity2dPoint(IM.Imaging.Image3D,System.Int32,System.Int32[],System.Single[])">
            <summary> Compute the 2D intensity curvature  (defined by K)) on a list of points with mirror boundary conditions
            </summary>
            <param name="image">The input image</param>
            <param name="inputBand">The input band</param>
            <param name="pointsIndexes">The list of indexes of points where to compute the curvature</param>
            <param name="pointsCurvature">The output list of curvatures computed at the given points</param>
        </member>
        <member name="M:IM.Library.Mathematics.Curvature.ComputeCurvatureIntensity2dPoint(IM.Imaging.Image3D,System.Int32,System.Int32[],System.Single[])">
            <summary> Compute the 2D intensity curvature  (defined by det(H(x,y))) on a list of points with mirror boundary conditions
            </summary>
            <param name="image">The input image</param>
            <param name="inputBand">The input band</param>
            <param name="pointsIndexes">The list of indexes of points where to compute the curvature</param>
            <param name="pointsCurvature">The output list of curvatures computed at the given points</param>
        </member>
        <member name="M:IM.Library.Mathematics.Curvature.ComputeMeanCurvatureMotion2D(IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D,System.Int32)">
            <summary>
            Compute the normalized mean curvature Div(Grad u/|Grad u|)
            </summary>
            <param name="input"></param>
            <param name="inputBand"></param>
            <param name="output"></param>
            <param name="outputBand"></param>
        </member>
        <member name="M:IM.Library.Mathematics.Curvature.Compute2DHessianEigenvalues(IM.Imaging.Image3D,System.Int32,System.Single)">
            <summary>
            Compute the Hessian Eigen Values of the Hessian Matrix for a 2D picture
            </summary>
            <param name="input">The input image</param>
            <param name="inputBand">The input channel</param>
            <returns>Return a 2 channels picture with the two eigenvalues</returns>
        </member>
        <member name="M:IM.Library.Mathematics.Curvature.Compute2D_SinBeta_CosBeta(IM.Imaging.Image3D,System.Int32)">
            <summary>
            
            </summary>
            <param name="input">input image</param>
            <param name="inputBand">input channel</param>
            <returns>Two channels image with Sin(Beta) on the first channel and Cos(Beta) on the second</returns>
        </member>
        <member name="M:IM.Library.Mathematics.Curvature.Compute2D_Lp_Lq(IM.Imaging.Image3D,System.Int32,System.Single)">
            <summary>
            
            </summary>
            <param name="input"></param>
            <param name="inputBand"></param>
            <param name="Sigma"></param>
            <returns></returns>
        </member>
        <member name="M:IM.Library.Mathematics.Curvature.DetectRidges(IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D,System.Int32,System.Single,System.Single)">
            <summary>
            
            </summary>
            <param name="input"></param>
            <param name="inputBand"></param>
            <param name="output"></param>
            <param name="outputBand"></param>
            <param name="Sigma"></param>
            <param name="ZeroThreshold"></param>
        </member>
        <member name="M:IM.Library.Mathematics.Curvature.DetectValleys(IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D,System.Int32,System.Single,System.Single)">
            <summary>
            
            </summary>
            <param name="input"></param>
            <param name="inputBand"></param>
            <param name="output"></param>
            <param name="outputBand"></param>
            <param name="Sigma"></param>
            <param name="ZeroThreshold"></param>
        </member>
        <member name="T:IM.Library.Mathematics.Curvature.GradientThreadHandler">
            <summary>
            Allows to compute gradient in a multithreaded environment.
            This class embedes an instance of the delegate of the function to evaluate 
            </summary>
        </member>
        <member name="F:IM.Library.Mathematics.Curvature.GradientThreadHandler.asyncOpsAreDone">
            <summary>
            For thread synchronisation
            </summary>
        </member>
        <member name="M:IM.Library.Mathematics.Curvature.GradientThreadHandler.#ctor(IM.Library.Delegates.FunctionDAtoD,System.Double[],System.Int32)">
            <summary>
            Basic constructor
            </summary>
            <param name="f">a delegate for the function to run</param>
            <param name="x">the parameters of the function</param>
            <param name="idx">additionnal value, can be used for synchronisation</param>
        </member>
        <member name="M:IM.Library.Mathematics.Curvature.GradientThreadHandler.run(System.Object)">
            <summary>
            The function to lauch in the threadpool
            </summary>
            <param name="dummy">Shall be null, just to match WaitCallBack definition</param>
        </member>
        <member name="T:IM.Library.Mathematics.Divergence">
            <summary> Divergence calculation toolbox
            </summary>
        </member>
        <member name="M:IM.Library.Mathematics.Divergence.ComputeDivergence(IM.Imaging.Image3D,IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D)">
            <summary> Compute the divergence of a 2D vector field
            </summary>
            <param name="u">the X component of the vector field</param>
            <param name="v">the Y component of the vector field</param>
            <param name="inputBand">the input band of the vector fields</param>
            <param name="output">the output image that will receive the result</param>
        </member>
        <member name="M:IM.Library.Mathematics.Divergence.ComputeDivergence(IM.Imaging.Image3D,IM.Imaging.Image3D,IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D)">
            <summary> Compute the divergence of a 2D vector field
            </summary>
            <param name="u">the X component of the vector field</param>
            <param name="v">the Y component of the vector field</param>
            <param name="w">the Z component of the vector field</param>
            <param name="inputBand">the input band of the vector fields</param>
            <param name="output">the output image that will receive the result</param>
        </member>
        <member name="T:IM.Library.Mathematics.Matrix.SingularValueDecomposition">
            <summary>
            	Singular Value Decomposition for a rectangular matrix.
            </summary>
            <remarks>
              For an m-by-n matrix <c>A</c> with <c>m >= n</c>, the singular value decomposition is
              an m-by-n orthogonal matrix <c>U</c>, an n-by-n diagonal matrix <c>S</c>, and
              an n-by-n orthogonal matrix <c>V</c> so that <c>A = U * S * V'</c>.
              The singular values, <c>sigma[k] = S[k,k]</c>, are ordered so that
              <c>sigma[0] >= sigma[1] >= ... >= sigma[n-1]</c>.
              The singular value decompostion always exists, so the constructor will
              never fail. The matrix condition number and the effective numerical
              rank can be computed from this decomposition.
            </remarks>
        </member>
        <member name="M:IM.Library.Mathematics.Matrix.SingularValueDecomposition.#ctor(IM.Library.Mathematics.Matrix.Matrix)">
            <summary>Construct singular value decomposition.</summary>
        </member>
        <member name="P:IM.Library.Mathematics.Matrix.SingularValueDecomposition.Condition">
            <summary>Returns the condition number <c>max(S) / min(S)</c>.</summary>
        </member>
        <member name="P:IM.Library.Mathematics.Matrix.SingularValueDecomposition.Norm2">
            <summary>Returns the Two norm.</summary>
        </member>
        <member name="P:IM.Library.Mathematics.Matrix.SingularValueDecomposition.Rank">
            <summary>Returns the effective numerical matrix rank.</summary>
            <value>Number of non-negligible singular values.</value>
        </member>
        <member name="P:IM.Library.Mathematics.Matrix.SingularValueDecomposition.Diagonal">
            <summary>Return the one-dimensional array of singular values.</summary>		
        </member>
        <member name="T:IM.Library.Mathematics.Matrix.Matrix">
             <summary>Matrix provides the fundamental operations of numerical linear algebra.</summary>
             <list type="table">
             <listheader> <term>Version</term> <description>Changes</description> </listheader>
            <item> <term>1.1</term> <description>(AG) first operationnal build</description> </item>
             <item> <term>1.1</term> <description>(BL) changed the Array assessor from internal to public to allow easy matrix2array conversion</description> </item>
             </list>
        </member>
        <member name="M:IM.Library.Mathematics.Matrix.Matrix.#ctor(System.Int32,System.Int32)">
            <summary>Constructs an empty matrix of the given size.</summary>
            <param name="rows">Number of rows.</param>
            <param name="columns">Number of columns.</param>
        </member>
        <member name="M:IM.Library.Mathematics.Matrix.Matrix.#ctor(System.Int32,System.Int32,System.Double)">
            <summary>Constructs a matrix of the given size and assigns a given value to all diagonal elements.</summary>
            <param name="rows">Number of rows.</param>
            <param name="columns">Number of columns.</param>
            <param name="value">Value to assign to the diagnoal elements.</param>
        </member>
        <member name="M:IM.Library.Mathematics.Matrix.Matrix.#ctor(System.Double[][])">
            <summary>Constructs a matrix from the given array.</summary>
            <param name="value">The array the matrix gets constructed from.</param>
        </member>
        <member name="M:IM.Library.Mathematics.Matrix.Matrix.Equals(System.Object)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:IM.Library.Mathematics.Matrix.Matrix.Equals(IM.Library.Mathematics.Matrix.Matrix)">
            <summary>
            Determines weather two instances are equal.
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:IM.Library.Mathematics.Matrix.Matrix.Equals(IM.Library.Mathematics.Matrix.Matrix,IM.Library.Mathematics.Matrix.Matrix)">
            <summary>
            Determines weather two instances are equal.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:IM.Library.Mathematics.Matrix.Matrix.GetHashCode">
            <summary>Serves as a hash function for a particular type, suitable for use in hashing algorithms and data structures like a hash table.</summary>
        </member>
        <member name="M:IM.Library.Mathematics.Matrix.Matrix.Submatrix(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Returns a sub matrix extracted from the current matrix.</summary>
            <param name="startRow">Start row index</param>
            <param name="endRow">End row index</param>
            <param name="startColumn">Start column index</param>
            <param name="endColumn">End column index</param>
        </member>
        <member name="M:IM.Library.Mathematics.Matrix.Matrix.Submatrix(System.Int32[],System.Int32[])">
            <summary>Returns a sub matrix extracted from the current matrix.</summary>
            <param name="rowIndexes">Array of row indices</param>
            <param name="columnIndexes">Array of column indices</param>
        </member>
        <member name="M:IM.Library.Mathematics.Matrix.Matrix.Submatrix(System.Int32,System.Int32,System.Int32[])">
            <summary>Returns a sub matrix extracted from the current matrix.</summary>
            <param name="i0">Starttial row index</param>
            <param name="i1">End row index</param>
            <param name="c">Array of row indices</param>
        </member>
        <member name="M:IM.Library.Mathematics.Matrix.Matrix.Submatrix(System.Int32[],System.Int32,System.Int32)">
            <summary>Returns a sub matrix extracted from the current matrix.</summary>
            <param name="r">Array of row indices</param>
            <param name="j0">Start column index</param>
            <param name="j1">End column index</param>
        </member>
        <member name="M:IM.Library.Mathematics.Matrix.Matrix.Clone">
            <summary>Creates a copy of the matrix.</summary>
        </member>
        <member name="M:IM.Library.Mathematics.Matrix.Matrix.Transpose">
            <summary>Returns the transposed matrix.</summary>
        </member>
        <member name="M:IM.Library.Mathematics.Matrix.Matrix.DiagMat">
            <summary>Returns the diagonal matrix.</summary>
        </member>
        <member name="M:IM.Library.Mathematics.Matrix.Matrix.Abs">
            <summary>Returns the matrix of absolute valued elements.</summary>
        </member>
        <member name="M:IM.Library.Mathematics.Matrix.Matrix.Negate(IM.Library.Mathematics.Matrix.Matrix)">
            <summary>Unary minus.</summary>
        </member>
        <member name="M:IM.Library.Mathematics.Matrix.Matrix.op_UnaryNegation(IM.Library.Mathematics.Matrix.Matrix)">
            <summary>Unary minus.</summary>
        </member>
        <member name="M:IM.Library.Mathematics.Matrix.Matrix.op_Equality(IM.Library.Mathematics.Matrix.Matrix,IM.Library.Mathematics.Matrix.Matrix)">
            <summary>Matrix equality.</summary>
        </member>
        <member name="M:IM.Library.Mathematics.Matrix.Matrix.op_Inequality(IM.Library.Mathematics.Matrix.Matrix,IM.Library.Mathematics.Matrix.Matrix)">
            <summary>Matrix inequality.</summary>
        </member>
        <member name="M:IM.Library.Mathematics.Matrix.Matrix.Add(IM.Library.Mathematics.Matrix.Matrix,IM.Library.Mathematics.Matrix.Matrix)">
            <summary>Matrix addition.</summary>
        </member>
        <member name="M:IM.Library.Mathematics.Matrix.Matrix.op_Addition(IM.Library.Mathematics.Matrix.Matrix,IM.Library.Mathematics.Matrix.Matrix)">
            <summary>Matrix addition.</summary>
        </member>
        <member name="M:IM.Library.Mathematics.Matrix.Matrix.Subtract(IM.Library.Mathematics.Matrix.Matrix,IM.Library.Mathematics.Matrix.Matrix)">
            <summary>Matrix subtraction.</summary>
        </member>
        <member name="M:IM.Library.Mathematics.Matrix.Matrix.op_Subtraction(IM.Library.Mathematics.Matrix.Matrix,IM.Library.Mathematics.Matrix.Matrix)">
            <summary>Matrix subtraction.</summary>
        </member>
        <member name="M:IM.Library.Mathematics.Matrix.Matrix.Multiply(IM.Library.Mathematics.Matrix.Matrix,System.Double)">
            <summary>Matrix-scalar multiplication.</summary>
        </member>
        <member name="M:IM.Library.Mathematics.Matrix.Matrix.op_Multiply(IM.Library.Mathematics.Matrix.Matrix,System.Double)">
            <summary>Matrix-scalar multiplication.</summary>
        </member>
        <member name="M:IM.Library.Mathematics.Matrix.Matrix.Multiply(IM.Library.Mathematics.Matrix.Matrix,IM.Library.Mathematics.Matrix.Matrix)">
            <summary>Matrix-matrix multiplication.</summary>
        </member>
        <member name="M:IM.Library.Mathematics.Matrix.Matrix.op_Multiply(IM.Library.Mathematics.Matrix.Matrix,IM.Library.Mathematics.Matrix.Matrix)">
            <summary>Matrix-matrix multiplication.</summary>
        </member>
        <member name="M:IM.Library.Mathematics.Matrix.Matrix.Solve(IM.Library.Mathematics.Matrix.Matrix)">
            <summary>Returns the LHS solution vetor if the matrix is square or the least squares solution otherwise.</summary>
        </member>
        <member name="M:IM.Library.Mathematics.Matrix.Matrix.Random(System.Int32,System.Int32)">
            <summary>Returns a matrix filled with random values.</summary>
        </member>
        <member name="M:IM.Library.Mathematics.Matrix.Matrix.Diagonal(System.Int32,System.Int32,System.Double)">
            <summary>Returns a diagonal matrix of the given size.</summary>
        </member>
        <member name="M:IM.Library.Mathematics.Matrix.Matrix.Zeros(System.Int32,System.Int32)">
            <summary>Returns a entries of zero matrix of the given size.</summary>
        </member>
        <member name="M:IM.Library.Mathematics.Matrix.Matrix.Ones(System.Int32,System.Int32)">
            <summary>Returns a entries of one matrix of the given size.</summary>
        </member>
        <member name="M:IM.Library.Mathematics.Matrix.Matrix.ToString">
            <summary>Returns the matrix in a textual form.</summary>
        </member>
        <member name="P:IM.Library.Mathematics.Matrix.Matrix.Rows">
            <summary>Returns the number of columns.</summary>
        </member>
        <member name="P:IM.Library.Mathematics.Matrix.Matrix.Columns">
            <summary>Returns the number of columns.</summary>
        </member>
        <member name="P:IM.Library.Mathematics.Matrix.Matrix.Square">
            <summary>Return <see langword="true"/> if the matrix is a square matrix.</summary>
        </member>
        <member name="P:IM.Library.Mathematics.Matrix.Matrix.Symmetric">
            <summary>Returns <see langword="true"/> if the matrix is symmetric.</summary>
        </member>
        <member name="P:IM.Library.Mathematics.Matrix.Matrix.Item(System.Int32,System.Int32)">
            <summary>Access the value at the given location.</summary>
        </member>
        <member name="P:IM.Library.Mathematics.Matrix.Matrix.Norm1">
            <summary>Returns the One Norm for the matrix.</summary>
            <value>The maximum column sum.</value>
        </member>
        <member name="P:IM.Library.Mathematics.Matrix.Matrix.InfinityNorm">
            <summary>Returns the Infinity Norm for the matrix.</summary>
            <value>The maximum row sum.</value>
        </member>
        <member name="P:IM.Library.Mathematics.Matrix.Matrix.FrobeniusNorm">
            <summary>Returns the Frobenius Norm for the matrix.</summary>
            <value>The square root of sum of squares of all elements.</value>
        </member>
        <member name="P:IM.Library.Mathematics.Matrix.Matrix.Inverse">
            <summary>Inverse of the matrix if matrix is square, pseudoinverse otherwise.</summary>
        </member>
        <member name="P:IM.Library.Mathematics.Matrix.Matrix.Determinant">
            <summary>Determinant if matrix is square.</summary>
        </member>
        <member name="P:IM.Library.Mathematics.Matrix.Matrix.Trace">
            <summary>Returns the trace of the matrix.</summary>
            <returns>Sum of the diagonal elements.</returns>
        </member>
        <member name="T:IM.Library.Mathematics.GaussianMixtureEM">
            <summary>
            EM algorithm for an N-dimensional K-Gaussian mixture. Find the 3xK parameters of a K Gaussian mixture by Maximum of likelihood from onto a N-dimensionnal dataset.
            parameters can be access directly as (a,m,S)
            <p>Author: A. Genovesio</p>
            </summary>
        </member>
        <member name="M:IM.Library.Mathematics.GaussianMixtureEM.#ctor(IM.Library.Mathematics.Matrix.Matrix[],System.Int32,System.Single,System.Single,System.Boolean)">
            <summary>
            Constructor with a (uniform) random initialisations of Gaussian means among data points
            </summary>
            <param name="x">The table of data points</param>
            <param name="k">The number of Gaussian</param>
            <param name="sigma2">The initial value of sigma2 for all Gaussian (diag of Covariance Matrix)</param>
            <param name="logLikelihoodDiff">The log likelihood value difference for wich the EM is said to converge</param>
            <param name="verbose">Show informations on IM Console</param>
        </member>
        <member name="M:IM.Library.Mathematics.GaussianMixtureEM.#ctor(IM.Library.Mathematics.Matrix.Matrix[],IM.Library.Mathematics.Matrix.Matrix[],System.Single,System.Single,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="x">The table of data points</param>
            <param name="m">the table of initial means</param>
            <param name="sigma2">The initial value of sigma2 for all Gaussian (diag of Covariance Matrix)</param>
            <param name="logLikelihoodDiff">The log likelihood value difference for wich the EM is said to converge</param>
            <param name="verbose">Show informations on IM Console</param>
        </member>
        <member name="M:IM.Library.Mathematics.GaussianMixtureEM.Run">
            <summary>
            Do the main job
            </summary>
        </member>
        <member name="M:IM.Library.Mathematics.GaussianMixtureEM.GetClasses">
            <summary>
            Get the index of the closest Gaussian of each data point for further purposes. This array is created each time this accessor is call.
            </summary>
            <returns></returns>
        </member>
        <member name="P:IM.Library.Mathematics.GaussianMixtureEM.a">
            <summary>
            Mixture weights
            </summary>
        </member>
        <member name="P:IM.Library.Mathematics.GaussianMixtureEM.m">
            <summary>
            Mixture means
            </summary>
        </member>
        <member name="P:IM.Library.Mathematics.GaussianMixtureEM.S">
            <summary>
            Mixture covariances
            </summary>
        </member>
        <member name="M:IM.Library.Mathematics.RandomGenerators.DistributionGenerator.Distribution_Generator(System.Single[],System.Boolean)">
            <summary>
            Return a random number following a distribution given as a discret array
            </summary>
            <param name="DistributionFunction">The distribution function (doesn't need to be normalized</param>
            <param name="IsNormalized">if "true" the result is normalized between 0..1</param>
            <returns>Return the value (the "bin")</returns>
        </member>
        <member name="M:IM.Library.Mathematics.RandomGenerators.DistributionGenerator.Distribution_RandomGenerator(System.Single[],System.Boolean)">
            <summary>
            Return a random number following a distribution given as a discret array
            D.F.this version uses the static random and avoids a bug
            </summary>
            <param name="DistributionFunction">The distribution function (doesn't need to be normalized</param>
            <param name="IsNormalized">if "true" the result is normalized between 0..1</param>
            <returns>Return the value (the "bin")</returns>
        </member>
        <member name="M:IM.Library.Mathematics.RandomGenerators.DistributionGenerator.Distribution_Generator(System.Single[],System.Int32,System.Boolean)">
            <summary>
            Return an array of random numbers following a distribution given as a discret array
            </summary>
            <param name="DistributionFunction">The distribution function (doesn't need to be normalized</param>
            <param name="IsNormalized">if "true" the data are normalized between 0..1</param>
            <returns>Return the array</returns>
        </member>
        <member name="M:IM.Library.Mathematics.RandomGenerators.DistributionGenerator.Distribution_Generator(IM.Library.Delegates.FunctionFAtoF,System.Single,System.Single,System.Single,System.Int32,System.Boolean)">
            <summary>
            Return an array of random numbers following a distribution given via an user-defined function
            </summary>
            <param name="func">The probability density function (should be non-negative)</param>
            <param name="min">Function Definition Interval Minimum</param>
            <param name="max">Function Definition Interval Maximum</param>
            <param name="step">Function Sampling</param>
            <param name="IsNormalized">if "true" the data are normalized between 0..1</param>
            <returns>Return the array</returns>
        </member>
        <member name="T:IM.Library.Mathematics.RandomGenerators.IRandomGenerator">
            <summary> Interface describing a random number generator
            </summary>
        </member>
        <member name="M:IM.Library.Mathematics.RandomGenerators.IRandomGenerator.Random(System.Double[])">
            <summary> Generates a new number
            </summary>
            <returns>the new generated number</returns>
        </member>
        <member name="T:IM.Library.Mathematics.RandomGenerators.ParkMillerBaysDurham">
            <summary> Class implementing the Park-Miller random number generator with Bays-Durham shuffle and safeguards.
            </summary>
            <remarks>refered to by Numerical Recipes as "ran1"</remarks>
        </member>
        <member name="M:IM.Library.Mathematics.RandomGenerators.ParkMillerBaysDurham.#ctor">
            <summary> Creates a new Park-Miller-Bays-Durham generator with default seed = 1
            </summary>
        </member>
        <member name="M:IM.Library.Mathematics.RandomGenerators.ParkMillerBaysDurham.#ctor(System.Int64)">
            <summary> Creates a new Park-Miller-Bays-Durham generator with given seed
            </summary>
            <param name="theSeed">The generator seed</param>
        </member>
        <member name="T:IM.Library.Mathematics.RandomGenerators.Gauss">
            <summary> Class implementing a gaussian random generator with 0 mean and unit variance
            </summary>
        </member>
        <member name="M:IM.Library.Mathematics.RandomGenerators.Gauss.#ctor">
            <summary> Creates a new gaussian generator with default seed 1
            </summary>
        </member>
        <member name="M:IM.Library.Mathematics.RandomGenerators.Gauss.#ctor(System.Int64)">
            <summary> Creates a new gaussian generator with specified seed
            </summary>
            <param name="seed"></param>
        </member>
        <member name="T:IM.Library.Mathematics.RandomGenerators.Poisson">
            <summary> Class implementing a poisson random generator
            </summary>
        </member>
        <member name="M:IM.Library.Mathematics.RandomGenerators.Poisson.#ctor(System.Double)">
            <summary> Creates a new Poisson generator with given mean and default seed 1
            </summary>
            <param name="threshold">threshold between poisson and normal distribution (12 in NR, 50 in Matlab)</param>
        </member>
        <member name="M:IM.Library.Mathematics.RandomGenerators.Poisson.#ctor(System.Int64,System.Double)">
            <summary> Creates a new Poisson generator with given mean and seed
            </summary>
            <param name="seed">the generator seed</param>
            <param name="threshold">threshold between poisson and normal distribution (12 in NR, 50 in Matlab)</param>
        </member>
        <member name="T:IM.Library.Mathematics.Distributions">
            <remarks> Various Math tools for float arrays
            </remarks>
            <list type="table">
            <listheader> <term>Version</term> <description>Changes</description> </listheader>
            <item> <term>3.0</term><description>(AD) Migrated to object framewwork</description> </item>
            <item> <term>2.0</term><description>(TD) All major polynomial distributions</description> </item>
            <item> <term>1.0</term><description>(TD) First operational build: All major probability distributions</description> </item>
            </list>
        </member>
        <member name="M:IM.Library.Mathematics.Distributions.#ctor">
            <summary> Creates a new instance of the Distributions toolbox
            </summary>
        </member>
        <member name="M:IM.Library.Mathematics.Distributions.Poisson(System.Single[],System.Double)">
            <summary> Computes the Poisson Distribution (discret distribution)
            </summary>
            <param name="output">the output array</param>
            <param name="mu">Poisson distribution variance, positive real number equal to the expected
            number of occurrences during the given interval. For instance, if the events occur on average
            every 4 minutes, and you are interested in the number of events occurring in a 10 minute interval,
            you would use as model a Poisson distribution with Mu = 10/4 = 2.5 >= 0</param>
        </member>
        <member name="M:IM.Library.Mathematics.Distributions.Gaussian(System.Single[],System.Single,System.Single,System.Single,System.Single)">
            <summary> Computes the Gaussian Distribution
            </summary>
            <param name="output">the output array</param>
            <param name="mean">Mean distribution</param>
            <param name="standardDeviation">Standard Deviation</param>
            <param name="min">Minimum</param>
            <param name="max">Maximum</param>
        </member>
        <member name="M:IM.Library.Mathematics.Distributions.JacobiDensity(System.Single[],System.Single,System.Single,System.Single,System.Single)">
            <summary> Computes the Jacobi Density function (1-x)^a * (1-x)^b
            </summary>
            <param name="output">the output array</param>
            <param name="a">Coefficient a</param>
            <param name="b">Coefficient b</param>
            <param name="min">Minimum</param>
            <param name="max">Maximum</param>
        </member>
        <member name="M:IM.Library.Mathematics.Distributions.Cauchy(System.Single[],System.Single,System.Single,System.Single,System.Single)">
            <summary> Computes the Cauchy Distribution
            </summary>
            <param name="output">the output array</param>
            <param name="x0">Location parameter</param>
            <param name="gamma">Scale parameter</param>
            <param name="min">Minimum</param>
            <param name="max">Maximum</param>
        </member>
        <member name="M:IM.Library.Mathematics.Distributions.Uniform(System.Single[],System.Single,System.Single,System.Single,System.Single)">
            <summary> Computes the Uniform Distribution
            </summary>
            <param name="output">the output array</param>
            <param name="a">a parameter (beginning)</param>
            <param name="b">b parameter (ending)</param>
            <param name="min">Minimum</param>
            <param name="max">Maximum</param>
        </member>
        <member name="M:IM.Library.Mathematics.Distributions.Polynomial(System.Single[],System.Single,System.Single,System.Single,System.Single)">
            <summary> Computes a polynomial distribution
            </summary>
            <param name="output">the output array</param>
            <param name="degree">Polynomial Degree</param>
            <param name="factor">Multiplicative factor</param>
            <param name="min">Minimum</param>
            <param name="max">Maximum</param>
        </member>
        <member name="M:IM.Library.Mathematics.Distributions.Exponential(System.Single[],System.Single,System.Single,System.Single,System.Single)">
            <summary> Computes an exponential distribution e^(a*x)
            </summary>
            <param name="output">the output array</param>
            <param name="a">a factor</param>
            /// <param name="factor">Multiplicative factor</param>
            <param name="min">Minimum</param>
            <param name="max">Maximum</param>
        </member>
        <member name="M:IM.Library.Mathematics.Distributions.TukeyLambda(System.Single[],System.Single,System.Single,System.Single)">
            <summary> Computes the Tukey-Lambda Distribution
            </summary>
            <param name="output">the output array</param>
            <param name="lambda">Lambda parameter </param>
            <param name="min">Minimum</param>
            <param name="max">Maximum</param>
        </member>
        <member name="M:IM.Library.Mathematics.Distributions.Tchebychev(System.Single[],System.Int32,System.Single,System.Single)">
            <summary> Computes the Tchebychev polynomial
            </summary>
            <param name="output">the output array</param>
            <param name="k">degree</param>
            <param name="min">Minimum</param>
            <param name="max">Maximum</param>
        </member>
        <member name="M:IM.Library.Mathematics.Distributions.Jacobi(System.Single[],System.Int32,System.Single,System.Single,System.Single,System.Single)">
            <summary> Computes the Jacobi polynomial
            </summary>
            <param name="output">the output array</param>
            <param name="n">polynomial degree</param>
            <param name="a">a parameter</param>
            <param name="b">b parameter</param>
            <param name="min">Minimum</param>
            <param name="max">Maximum</param>
        </member>
        <member name="M:IM.Library.Mathematics.Distributions.Gegenbauer(System.Single[],System.Int32,System.Single,System.Single,System.Single)">
            <summary> Computes the Gegenbauer polynomial (over [-1,+1])
            </summary>
            <param name="output">the output array</param>
            <param name="n">degree</param>
            <param name="c">factor > -0.5</param>
            <param name="min">Minimum</param>
            <param name="max">Maximum</param>
        </member>
        <member name="M:IM.Library.Mathematics.Distributions.Legendre(System.Single[],System.Int32,System.Single,System.Single)">
            <summary> Computes the Legendre polynomial (over [-1,1])
            </summary>
            <param name="output">the output array</param>
            <param name="k">degree</param>
            <param name="min">Minimum</param>
            <param name="max">Maximum</param>
        </member>
        <member name="M:IM.Library.Mathematics.Distributions.Hermite(System.Single[],System.Int32,System.Single,System.Single)">
            <summary> Computes the Hermite polynomial (over R)
            </summary>
            <param name="output">the output array</param>
            <param name="k">degree</param>
            <param name="min">Minimum</param>
            <param name="max">Maximum</param>
        </member>
        <member name="M:IM.Library.Mathematics.Distributions.Laguerre(System.Single[],System.Int32,System.Single,System.Single)">
            <summary> Computes the Laguerre polynomial (over R+)
            </summary>
            <param name="output">the output array</param>
            <param name="k">degree</param>
            <param name="min">Minimum</param>
            <param name="max">Maximum</param>
        </member>
        <member name="M:IM.Library.Mathematics.Matrix.GeneralizedEigenvalueDecomposition.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:IM.Library.Mathematics.Matrix.GeneralizedEigenvalueDecomposition.Decomposition(IM.Library.Mathematics.Matrix.Matrix,IM.Library.Mathematics.Matrix.Matrix,IM.Library.Mathematics.Matrix.Matrix@,IM.Library.Mathematics.Matrix.Matrix@)" -->
        <!-- Badly formed XML comment ignored for member "M:IM.Library.Mathematics.Matrix.GeneralizedEigenvalueDecomposition.Decomposition(System.Double[0:,0:],System.Double[0:,0:],System.Double[]@,System.Double[0:,0:]@)" -->
        <member name="M:IM.Library.Mathematics.Matrix.GeneralizedEigenvalueDecomposition.SymmetricMatrixGEVD(System.Double[0:,0:],System.Int32,System.Boolean,System.Double[0:,0:]@,System.Boolean,System.Int32,System.Int32,System.Double[]@,System.Double[0:,0:]@)">
            <summary>
            Algorithm for solving the following generalized symmetric positive-definite eigenproblem:
            A*x = lambda*B*x (1) or A*B*x = lambda*x (2) or B*A*x = lambda*x (3).
            where A is A symmetric matrix, B - symmetric positive-definite matrix.
            The problem is solved by reducing it to an ordinary  symmetric eigenvalue problem.
            Result is TRUE if the problem was solved successfully.
            </summary>
            <para name="A">Symmetric matrix which is given by its upper or lower triangular part</para>
            <para name="N">Size of matrices A and B</para>
            <para name="IsUpperA">storage format of matrix A</para>
            <para name="B">Symmetric positive-definite matrix which is given by its upper or lower triangular part</para>
            <para name="IsUpperB">Storage format of matrix B</para>
            <para name="ZNeeded">ZNeeded == 0 : the eigenvectors are not returned / ZNeeded == 1 : the eigenvectors are returned</para>
            <para name="ProblemType">ProblemType == 1 : solve A*x = lambda*B*x / ProblemType == 2 : solve A*B*x = lambda*x / ProblemType == 3 : solve B*A*x = lambda*x</para>
            <para name="D">Eigenvalues in ascending order</para>
            <para name="Z">Eigenvectors corresponding to D</para>
        </member>
        <member name="T:IM.Library.Mathematics.Optimization.Minimization">
            <summary> Class defining Minimization operations.</summary>
            <list type="table">
            <listheader> <term>Version</term> <description>Changes</description> </listheader>
            <item> <term>1.1</term> <description>(TD) add FixedStepHessianDescent</description> </item>
            <item> <term>1.0</term> <description>(TD) first operational build : Brutal force + FixedStepGradientDescent</description> </item>
            </list>
        </member>
        <member name="M:IM.Library.Mathematics.Optimization.Minimization.BrutalForce(IM.Library.Delegates.FunctionDAtoD,System.Double[],System.Double[],System.Double[],System.Double[])">
            <summary>
            Find the minimum of a function by trying every value of the space (only for 2 or 3 dimensions)
            </summary>
            <param name="func">Function to minimize</param>
            <param name="parameters">parameters array, these parameter will be replace by the results</param>
            <param name="Min">Minimum for each parameter</param>
            <param name="Max">Maximum for each parameter</param>
            <param name="Step">Research step</param>
            <returns>return the minimum value of the function</returns>
        </member>
        <member name="M:IM.Library.Mathematics.Optimization.Minimization.combine(IM.Library.Delegates.FunctionDAtoD,System.Double[],System.Single[],System.Single[],System.Single[],System.Boolean)">
            <summary>
            
            </summary>
            <param name="func">function</param>
            <param name="parameters">paramters to optimize</param>
            <param name="min">minima</param>
            <param name="max">maxima</param>
            <param name="step">steps for each parameter</param>
            <param name="ProgressBar">display progress bar</param>
            <returns>return the minimum value of the function</returns>
        </member>
        <member name="M:IM.Library.Mathematics.Optimization.Minimization.FixedStepGradientDescent(IM.Library.Delegates.FunctionFAtoF,System.Single[],System.Single[],System.Single[],System.Single[])">
            <summary>
            Function minimization by gradient fixed step descent in an N-d space
            </summary>
            <param name="func">Function to minimize</param>
            <param name="parameters">Minimum coordinates</param>
            <param name="Min">Lower limits of the function</param>
            <param name="Max">Upper limits of the function</param>
            <param name="Step">Fixed step</param>
            <returns></returns>
        </member>
        <member name="M:IM.Library.Mathematics.Optimization.Minimization.FixedStepGradientDescent(IM.Library.Delegates.FunctionDAtoD,System.Double[],System.Double[],System.Double[],System.Double[])">
            <summary>
            Function minimization by gradient fixed step descent in an N-d space
            </summary>
            <param name="func">Function to minimize</param>
            <param name="parameters">Minimum coordinates</param>
            <param name="Min">Lower limits of the function</param>
            <param name="Max">Upper limits of the function</param>
            <param name="Step">Fixed step</param>
            <returns></returns>
        </member>
        <member name="M:IM.Library.Mathematics.Optimization.Minimization.FixedStepHessianDescent(IM.Library.Delegates.FunctionFAtoF,System.Single[],System.Single[],System.Single[],System.Single)">
            <summary>
            Function minimization by Hessian fixed step descent in an N-d space
            </summary>
            <param name="func">Function to minimize</param>
            <param name="parameters">Minimum coordinates</param>
            <param name="Min">Lower limits of the function</param>
            <param name="Max">Upper limits of the function</param>
            <param name="Step">Fixed step</param>
            <returns></returns>
        </member>
        <member name="M:IM.Library.Mathematics.Optimization.Minimization.ConjugateGradientMethod(System.Double[],System.Double,IM.Library.Delegates.FunctionDAtoD,System.Int32@)">
            <summary>N-dimensional Fletcher-Reeves-Polak-Ribiere minimization of a function given a starting point and the gradient function
            </summary>
            <param name="p">the N-dimensional starting point</param>
            <param name="ftol">the convergence tolerance</param>
            <param name="Func">the function to minimize</param>
            <param name="iter">return the number of iterations performed</param>
        </member>
        <member name="M:IM.Library.Mathematics.Optimization.Minimization.ConjugateGradientMethod(System.Double[],System.Double,System.Single,IM.Library.Delegates.FunctionDAtoD,System.Int32@)">
            <summary>N-dimensional Fletcher-Reeves-Polak-Ribiere minimization of a function given a starting point and the gradient function
            </summary>
            <param name="p">the N-dimensional starting point</param>
            <param name="ftol">the convergence tolerance</param>
            <param name="Func">the function to minimize</param>
            <param name="iter">return the number of iterations performed</param>
        </member>
        <member name="T:IM.Library.Mathematics.MathTools">
            <remarks> Various Math tools for float arrays or images
            </remarks>
            <list type="table">
            <listheader> <term>Version</term> <description>Changes</description> </listheader>
            <item> <term>2.3</term> <description>(TD) Anscombe Transform</description> </item>
            <item> <term>2.2</term> <description>(AD) added rescale routines with both min and max bounds</description> </item>
            <item> <term>2.1</term> <description>(TD) added harmonic mean</description> </item>
            <item> <term>2.0</term> <description>(AD) migrated to object framework</description> </item>
            <item> <term>1.8</term> <description>(AD) overloaded routines to restrict the computation according to binary masks</description> </item>
            <item> <term>1.7</term> <description>(AD) added "Skewness" and "Kurtosis" routines</description> </item>
            <item> <term>1.6</term> <description>(AD) added basic "in-place" operators (Add,Subtract,Multiply,Divide)</description> </item>
            <item> <term>1.5R1</term> <description>(AD) overloaded routines to handle start and end offsets</description> </item>
            <item> <term>1.5</term> <description>(TD) added "Std", "Abs" and "MAD" routines</description> </item>
            <item> <term>1.4R1</term> <description>(TD) removed useless overloads</description> </item>
            <item> <term>1.4</term> <description>(AD) added "Median" routines</description> </item>
            <item> <term>1.3</term> <description>(AD) added "Variance" routines</description> </item>
            <item> <term>1.2R1</term> <description>(AD) reordered cross-calls between methods</description> </item>
            <item> <term>1.2</term> <description>(AD) added "Rescale" routines</description> </item>
            <item> <term>1.1R1</term> <description>(AD) overloaded all routines for various types of input</description> </item>
            <item> <term>1.1</term> <description>(AD) added "Min" and "Max" routines</description> </item>
            <item> <term>1.0</term> <description>(AD) first operational build, contains "Mean" routines</description> </item>
            </list>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.#ctor">
            <summary> Creates a new instance of the Math Toolbox
            </summary>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Add(System.Single[]@,System.Single[],System.Single)">
            <summary> Adds a scalar to a float array
            </summary>
            <param name="result">the (initialized) return array (can be a reference to the input array)</param>
            <param name="array">a float array</param>
            <param name="scalar">a scalar to add to each array element</param>
            <returns>the modified array</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Add(System.Single[]@,System.Single[],System.Single[])">
            <summary> Adds 2 float arrays
            </summary>
            <param name="result">the (initialized) return array (can be a reference to the input array)</param>
            <param name="array1">a float array</param>
            <param name="array2">a float array</param>
            <returns>the modified array</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Add(IM.Imaging.Image3D@,IM.Imaging.Image3D,System.Single)">
            <summary> Adds a scalar to an image
            </summary>
            <param name="result">the (initialized) return image (can be a reference to the input image)</param>
            <param name="image">an image</param>
            <param name="scalar">a scalar value</param>
            <returns>image + scalar</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Add(IM.Imaging.Image3D@,IM.Imaging.Image3D,IM.Imaging.Image3D)">
            <summary> Adds 2 images
            </summary>
            <param name="result">the (initialized) return image (can be a reference to the input image)</param>
            <param name="image1">an image</param>
            <param name="image2">an image</param>
            <returns>image1 + image2</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Subtract(System.Single[]@,System.Single[],System.Single)">
            <summary> Subtracts a scalar from all the values of a float array
            </summary>
            <param name="result">the (initialized) return array (can be a reference to the input array)</param>
            <param name="array">a float array</param>
            <param name="scalar">a scalar to subtract from each array element</param>
            <returns>the modified array</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Subtract(System.Single[]@,System.Single,System.Single[])">
            <summary> Subtracts a scalar from all the values of a float array
            </summary>
            <param name="result">the (initialized) return array (can be a reference to the input array)</param>
            <param name="array">a float array</param>
            <param name="scalar">a scalar to subtract from each array element</param>
            <returns>the modified array</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Subtract(System.Single[]@,System.Single[],System.Single[])">
            <summary> Subtracts 2 float arrays
            </summary>
            <param name="result">the (initialized) return array (can be a reference to the input array)</param>
            <param name="array1">a float array</param>
            <param name="array2">a float array</param>
            <returns>the modified array</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Subtract(IM.Imaging.Image3D@,IM.Imaging.Image3D,System.Single)">
            <summary> Subtracts a scalar value from an image
            </summary>
            <param name="result">the (initialized) return image (can be a reference to the input image)</param>
            <param name="image">an image</param>
            <param name="scalar">a scalar value</param>
            <returns>image - scalar</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Subtract(IM.Imaging.Image3D@,System.Single,IM.Imaging.Image3D)">
            <summary> Subtracts an image from a scalar value (i.e. from an image filled with a scalar value)
            </summary>
            <param name="result">the (initialized) return image (can be a reference to the input image)</param>
            <param name="image">an image</param>
            <param name="scalar">a scalar value</param>
            <returns>scalar - image</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Subtract(IM.Imaging.Image3D@,IM.Imaging.Image3D,IM.Imaging.Image3D)">
            <summary> Subtracts 2 images
            </summary>
            <param name="result">the (initialized) return image (can be a reference to the input image)</param>
            <param name="image1">an image</param>
            <param name="image2">an image</param>
            <returns>image1 - image2</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Multiply(System.Single[]@,System.Single[],System.Single)">
            <summary> Multiplies a scalar to all the values of a float array
            </summary>
            <param name="result">the (initialized) return array (can be a reference to the input array)</param>
            <param name="array">a float array</param>
            <param name="scalar">a scalar to multiply to each array element</param>
            <returns>the modified array</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Multiply(System.Single[]@,System.Single[],System.Single[])">
            <summary> Multiplies 2 float arrays
            </summary>
            <param name="result">the (initialized) return array (can be a reference to the input array)</param>
            <param name="array1">a float array</param>
            <param name="array2">a float array</param>
            <returns>the modified array</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Multiply(IM.Imaging.Image3D@,IM.Imaging.Image3D,System.Single)">
            <summary> Multiplies a scalar and an image
            </summary>
            <param name="result">the (initialized) return image (can be a reference to the input image)</param>
            <param name="image">an image</param>
            <param name="scalar">a scalar value</param>
            <returns>image * scalar</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Multiply(IM.Imaging.Image3D@,IM.Imaging.Image3D,IM.Imaging.Image3D)">
            <summary> Multiplies point-to-point 2 images
            </summary>
            <param name="result">the (initialized) return image (can be a reference to the input image)</param>
            <param name="image1">an image</param>
            <param name="image2">an image</param>
            <returns>image1 * image2</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Divide(System.Single[]@,System.Single[],System.Single)">
            <summary> Divides all the values of a float array by a scalar
            </summary>
            <param name="result">the (initialized) return array (can be a reference to the input array)</param>
            <param name="array">a float array</param>
            <param name="scalar">a scalar to divide each array element by</param>
            <returns>the modified array</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Divide(System.Single[]@,System.Single[],System.Single[])">
            <summary> Divides 2 float arrays
            </summary>
            <param name="result">the (initialized) return array (can be a reference to the input array)</param>
            <param name="array1">a float array</param>
            <param name="array2">a float array</param>
            <returns>the modified array</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Divide(IM.Imaging.Image3D@,IM.Imaging.Image3D,System.Single)">
            <summary> Divides an image by a scalar
            </summary>
            <param name="result">the (initialized) return image (can be a reference to the input image)</param>
            <param name="image">an image</param>
            <param name="scalar">a scalar value</param>
            <returns>image / scalar</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Divide(IM.Imaging.Image3D@,IM.Imaging.Image3D,IM.Imaging.Image3D)">
            <summary> Divides 2 images
            </summary>
            <param name="result">the (initialized) return image (can be a reference to the input image)</param>
            <param name="image1">an image</param>
            <param name="image2">an image</param>
            <returns>image1 / image2</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Pow(System.Single,System.Single)">
            <summary> Calculates the power of two scalar values
            </summary>
            <param name="scalar1">a scalar value</param>
            <param name="scalar2">a scalar value</param>
            <returns>scalar1 ^ scalar2</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Pow(System.Single[]@,System.Single[],System.Single)">
            <summary> Elevates a float array to a given power
            </summary>
            <param name="result">the (initialized) return array (can be a reference to the input array)</param>
            <param name="array">a float array</param>
            <param name="scalar">a scalar</param>
            <returns>array ^ scalar</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Pow(System.Single[]@,System.Single,System.Single[])">
            <summary> Elevates a scalar to each array-value power
            </summary>
            <param name="result">the (initialized) return array (can be a reference to the input array)</param>
            <param name="array">a float array</param>
            <param name="scalar">a scalar</param>
            <returns>scalar ^ array</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Pow(System.Single[]@,System.Single[],System.Single[])">
            <summary> Elevates a float array to a given power
            </summary>
            <param name="result">the (initialized) return array (can be a reference to the input array)</param>
            <param name="array1">a float array</param>
            <param name="array2">a float array</param>
            <returns>array1 ^ array2</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Pow(IM.Imaging.Image3D@,IM.Imaging.Image3D,System.Single)">
            <summary> Elevates a float array to a given power
            </summary>
            <param name="result">the (initialized) return image (can be a reference to the input image)</param>
            <param name="image">an image</param>
            <param name="scalar">a scalar value</param>
            <returns>image ^ scalar</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Pow(IM.Imaging.Image3D@,IM.Imaging.Image3D,IM.Imaging.Image3D)">
            <summary> Multiplies point-to-point 2 images
            </summary>
            <param name="result">the (initialized) return image (can be a reference to the input image)</param>
            <param name="image1">an image</param>
            <param name="image2">an image</param>
            <returns>image1 ^ image2</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Exp(System.Single)">
            <summary> Calculates the exponential power of a scalar
            </summary>
            <param name="scalar">the input value</param>
            <returns>e^scalar</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Log(System.Single)">
            <summary> Calculates the logarithm of a scalar
            </summary>
            <param name="scalar">the input value</param>
            <returns>log(scalar)</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Log(System.Single[]@,System.Single[])">
            <summary> Calculates the Logartihm of a float array
            </summary>
            <param name="result">the (initialized) return array (can be a reference to the input array)</param>
            <param name="array">a float array</param>
            <returns>log(array)</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Log(IM.Imaging.Image3D@,IM.Imaging.Image3D)">
            <summary> Calculates the Logartihm of an image
            </summary>
            <param name="result">the (initialized) return image (can be a reference to the input image)</param>
            <param name="image">an image</param>
            <returns>log(image)</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Factorial(System.Int32)">
            <summary>
            Returns a factorial of an integer number (n!)
            </summary>
            <param name="n">The value to be factorialized</param>
            <returns>The double precision result</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Abs(System.Single[],System.Single[])">
            <summary> Computes the absolute value of a float array
            </summary>
            <param name="input">the input array</param>
            <param name="output">the output array (can be a reference to the input)</param>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Abs(IM.Imaging.Image3D,IM.Imaging.Image3D)">
            <summary> Computes the absolute value of an image
            </summary>
            <param name="input">the input image</param>
            <param name="output">the output image (can be the input)</param>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.CutLow(System.Single[],System.Single[],System.Single,System.Single)">
            <summary> Return the array with new constant value for the input values lower than the threshold 
            </summary>
            <param name="input">the input array</param>
            <param name="threshold">the low threshold</param>
            <param name="newValue">the new value</param>
            <param name="output">the output array (can be a reference to the input)</param>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.CutHigh(System.Single[],System.Single[],System.Single,System.Single)">
            <summary> Return the array with new constant value for the input values higher than the threshold 
            </summary>
            <param name="input">the input array</param>
            <param name="threshold">the high threshold</param>
            <param name="newValue">the new value</param>
            <param name="output">the output array (can be a reference to the input)</param>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.ConvertToFloat(System.Int32[])">
            <summary> Converts an integer array into a float array
            </summary>
            <param name="array">an integer array</param>
            <returns>a float array</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Mean(System.Single[],System.Int32,System.Int32)">
            <summary> Computes the mean value in a range of a float array 
            </summary>
            <param name="input">input values</param>
            <param name="start">Index of the first value in the range, inclusive</param>
            <param name="end">Index of the first value in the range, exclusive</param>
            <returns>the mean value of the input array</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Mean(System.Single[])">
            <summary> Computes the mean value of a given float array 
            </summary>
            <param name="input">input values</param>
            <returns>the mean value of the input array</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Mean(System.Double[])">
            <summary> Computes the mean value of a given double array 
            </summary>
            <param name="input">input values</param>
            <returns>the mean value of the input array</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.HMean(System.Single[])">
            <summary> Computes the harmonic mean value of a given float array 
            </summary>
            <param name="input">input values</param>
            <returns>the harmonic mean value of the input array</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Mean(System.Single[],System.Single[])">
            <summary> Computes the mean value on a specific region of a float array 
            </summary>
            <param name="input">input values</param>
            <param name="mask">binary mask indicating which values to pick</param>
            <returns>the mean value of the input array</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Mean(System.Single[]@,IM.Imaging.Image3D)">
            <summary> Computes the mean value on each band of a 3D image 
            </summary>
            <param name="input">input image</param>
            <param name="output">output array that will contain the mean of each image band</param>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Median(System.Single[],System.Int32,System.Int32)">
            <summary> Computes the median value in a range of a float array 
            </summary>
            <param name="input">input values</param>
            <param name="start">Index of the first value in the range, inclusive</param>
            <param name="end">Index of the first value in the range, exclusive</param>
            <returns>the mean value of the input array</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Median(System.Single[],System.Boolean)">
            <summary> Computes the median value of a float array
            </summary>
            <param name="input">the input array</param>
            <param name="preserveData">Set to true if the input data should not be modified (slower)</param>
            <returns>The median value of the array</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Median(System.Single[],System.Single[])">
            <summary> Computes the median value on a specific region of a float array
            </summary>
            <param name="input">the input array</param>
            <param name="mask">binary mask indicating which values to pick</param>
            <returns>The median value of the array</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Median(System.Single[]@,IM.Imaging.Image3D)">
            <summary> Computes the median value on each band of an image
            </summary>
            <param name="input">the input array</param>
            <param name="output">output array that will contain the median of each image band</param>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.MAD(System.Single[],System.Int32,System.Int32,System.Boolean)">
            <summary> Computes the median absolute deviation value of a float array
            </summary>
            <param name="input">the input array</param>
            <param name="start">Index of the first value in the range, inclusive</param>
            <param name="end">Index of the first value in the range, exclusive</param>
            <param name="normalPopulation">multiply the result by 1.4826 for a normal population</param>
            <returns>The median absolute value of the array</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.MAD(System.Single[],System.Boolean)">
            <summary> Computes the median absolute deviation value of a float array
            </summary>
            <param name="input">the input array</param>
            <param name="normalPopulation">multiply the result by 1.4826 for a normal population</param>
            <returns>The median absolute value of the array</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.MAD(System.Single[],System.Single[],System.Boolean)">
            <summary> Computes the median absolute deviation value on a specific region of a float array
            </summary>
            <param name="input">the input array</param>
            <param name="mask">binary mask indicating which values to pick</param>
            <param name="normalPopulation">multiply the result by 1.4826 for a normal population</param>
            <returns>The median absolute value of the array</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.MAD(System.Single[]@,IM.Imaging.Image3D,System.Boolean)">
            <summary> Computes the median absolute deivation value on each band of an image
            </summary>
            <param name="input">the input array</param>
            <param name="normalPopulation">multiply the result by 1.4826 for a normal population</param>
            <param name="output">output array that will contain the median absolute deviation of each image band</param>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Min(System.Single[],System.Int32,System.Int32)">
            <summary> Computes the minimum value in a range of a float array 
            </summary>
            <param name="input">input values</param>
            <param name="start">Index of the first value in the range, inclusive</param>
            <param name="end">Index of the first value in the range, exclusive</param>
            <returns>the minimum value of the input array</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Min(System.Single[])">
            <summary> Computes the minimum value of a given float array 
            </summary>
            <param name="input">input values</param>
            <returns>the minimum value of the input array</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Min(System.Single[],System.Int32@)">
            <summary> Computes the minimum value of a given float array 
            </summary>
            <param name="input">input values</param>
            <param name="Pos">output position</param>
            <returns>the minimum value of the input array, and the position of the minimum</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Min(System.Single[],System.Single[])">
            <summary> Computes the minimum value on a specific region of a given float array 
            </summary>
            <param name="input">input values</param>
            <param name="mask">binary mask indicating which values to pick</param>
            <returns>the minimum value of the input array</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Min(IM.Imaging.Image3D)">
            <summary> Computes the minimum value on each band of a 3D image 
            </summary>
            <param name="input">input image</param>
            <param name="output">output array that will contain the minimum value of each image band</param>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Max(System.Single[],System.Int32,System.Int32)">
            <summary> Computes the maximum value in a range of a float array 
            </summary>
            <param name="input">input values</param>
            <param name="start">Index of the first value in the range, inclusive</param>
            <param name="end">Index of the first value in the range, exclusive</param>
            <returns>the maximum value of the input array</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Max(System.Single[])">
            <summary> Computes the maximum value of a given float array 
            </summary>
            <param name="input">input values</param>
            <returns>the maximum value of the input array</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Max(System.Single[],System.Int32@)">
            <summary> Computes the maximum value of a given float array 
            </summary>
            <param name="input">input values</param>
            <param name="Pos">output position</param>
            <returns>the maximum value of the input array, and the position of the maximum</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Max(System.Single[],System.Single[],System.Int32@)">
            <summary> Computes the maximum value on a specific region of a given float array 
            </summary>
            <param name="input">input values</param>
            <param name="mask">binary mask indicating which values to pick</param>
            <param name="Pos">output position</param>
            <returns>the maximum value of the input array, and the position of the maximum</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Max(System.Single[],System.Single[])">
            <summary> Computes the maximum value on a specific region of a given float array 
            </summary>
            <param name="input">input values</param>
            <param name="mask">binary mask indicating which values to pick</param>
            <returns>the maximum value of the input array</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Max(IM.Imaging.Image3D)">
            <summary> Computes the maximum value on each band of a 3D image 
            </summary>
            <param name="input">input image</param>
            <param name="output">output array that will contain the maximum value of each image band</param>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Rescale(System.Single[],System.Single[],System.Single,System.Single)">
            <summary> Rescales the given float array to [minBound,maxBound] 
            </summary>
            <param name="input">the input array</param>
            <param name="output">the output array</param>
            <param name="minBound">the final minimum value</param>
            <param name="maxBound">the final maximum value</param>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Rescale(System.Single[],System.Single[],System.Single)">
            <summary> Rescales the given float array to [0,maxBound] 
            </summary>
            <param name="input">the input array</param>
            <param name="output">the output array</param>
            <param name="maxBound">the final maximum value</param>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Rescale(IM.Imaging.Image3D,IM.Imaging.Image3D,System.Single)">
            <summary> Rescales each band of the given image to [0,maxBound] 
            </summary>
            <param name="input">the input image</param>
            <param name="output">the output image</param>
            <param name="maxBound">the final maximum value</param>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Rescale(IM.Imaging.Image3D,IM.Imaging.Image3D,System.Single,System.Single)">
            <summary> Rescales each band of the given image to [minBound,maxBound] 
            </summary>
            <param name="input">the input image</param>
            <param name="output">the output image</param>
            <param name="minBound">the final minimum value</param>
            <param name="maxBound">the final maximum value</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:IM.Library.Mathematics.MathTools.Rescale(IM.Imaging.Image3D,System.Int32,System.Int32,IM.Imaging.Image3D,System.Int32,System.Int32,System.Single,System.Single)" -->
        <member name="M:IM.Library.Mathematics.MathTools.Rescale(IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D,System.Int32,System.Single,System.Single)">
            <summary>
            Rescale a specific band of an image 3D
            </summary>
            <param name="input">input image</param>
            <param name="inputChannel">input channel</param>
            <param name="output">output image</param>
            <param name="outputChannel">output channel</param>
            <param name="minBound">minimum boundary</param>
            <param name="maxBound">maximum boundary</param>
            <returns></returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.MeanCenteringStdStandarization(IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D,System.Int32)">
            <summary>
            Process the mean centering and the unit variance standardization
            </summary>
            <param name="input">Input Image</param>
            <param name="InputChannel">Input Channel</param>
            <param name="output">Output Image</param>
            <param name="OutputChannel">Output Channel</param>
            <returns></returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.MeanCentering(IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D,System.Int32)">
            <summary>
            Process the mean centering of the image
            </summary>
            <param name="input">Input Image</param>
            <param name="InputChannel">Input Channel</param>
            <param name="output">Output Image</param>
            <param name="OutputChannel">Output Channel</param>
            <returns></returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Sum(System.Single[])">
            <summary> Calculates the sum of all values in an array
            </summary>
            <param name="input">the array to sum up</param>
            <returns>the sum</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Var(System.Single[],System.Int32,System.Int32)">
            <summary> Computes the unbiased variance on a range of a float array 
            </summary>
            <param name="input">input values</param>
            <param name="start">Index of the first value in the range, inclusive</param>
            <param name="end">Index of the first value in the range, exclusive</param>
            <returns>the variance of the input array</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Var(System.Single[])">
            <summary> Computes the unbiased variance of a given float array 
            </summary>
            <param name="input">input values</param>
            <returns>the variance of the input array</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Var(System.Single[],System.Single[])">
            <summary> Computes the unbiased variance on a specific region of a float array 
            </summary>
            <param name="input">input values</param>
            <param name="mask">binary mask indicating which values to pick</param>
            <returns>the variance of the input array</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Var(System.Single[]@,IM.Imaging.Image3D)">
            <summary> Computes the unbiased variance on each band of a 3D image 
            </summary>
            <param name="input">input image</param>
            <param name="output">output array that will contain the variance of each image band</param>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Skew(System.Single[],System.Int32,System.Int32)">
            <summary> Computes the skewness on a range of a float array 
            </summary>
            <param name="input">input values</param>
            <param name="start">Index of the first value in the range, inclusive</param>
            <param name="end">Index of the first value in the range, exclusive</param>
            <returns>the skewness of the input array</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Skew(System.Single[])">
            <summary> Computes the skewness of a float array 
            </summary>
            <param name="input">input values</param>
            <returns>the skewness of the input array</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Skew(System.Single[],System.Single[])">
            <summary> Computes the skewness on a specific region of a float array 
            </summary>
            <param name="input">input values</param>
            <param name="mask">binary mask indicating which values to pick</param>
            <returns>the skewness of the input array</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Skew(System.Single[]@,IM.Imaging.Image3D)">
            <summary> Computes the skewness of a float array 
            </summary>
            <param name="input">input values</param>
            <param name="output">output array that will contain the skewness of each image band</param>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Kurt(System.Single[],System.Int32,System.Int32)">
            <summary> Computes the kurtosis on a range of a float array 
            </summary>
            <param name="input">input values</param>
            <param name="start">Index of the first value in the range, inclusive</param>
            <param name="end">Index of the first value in the range, exclusive</param>
            <returns>the kurtosis of the input array</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Kurt(System.Single[])">
            <summary> Computes the kurtosis of a float array 
            </summary>
            <param name="input">input values</param>
            <returns>the kurtosis of the input array</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Kurt(System.Single[],System.Single[])">
            <summary> Computes the kurtosis on a specific region of a float array 
            </summary>
            <param name="input">input values</param>
            <param name="mask">binary mask indicating which values to pick</param>
            <returns>the kurtosis of the input array</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Kurt(System.Single[]@,IM.Imaging.Image3D)">
            <summary> Computes the kurtosis of a float array 
            </summary>
            <param name="input">input values</param>
            <param name="output">output array that will contain the kurtosis of each image band</param>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Std(System.Single[],System.Int32,System.Int32)">
            <summary> Computes the unbiased standard deviation on a range of a float array 
            </summary>
            <param name="input">input values</param>
            <param name="start">Index of the first value in the range, inclusive</param>
            <param name="end">Index of the first value in the range, exclusive</param>
            <returns>the mean value of the input array</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Std(System.Single[])">
            <summary> Computes the unbiased standard deviation of a given float array 
            </summary>
            <param name="input">input values</param>
            <returns>the standard deviation value of the input array</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Std(System.Single[],System.Single[])">
            <summary> Computes the unbiased standard deviation on a specific region of a float array 
            </summary>
            <param name="input">input values</param>
            <param name="mask">binary mask indicating which values to pick</param>
            <returns>the standard deviation value of the input array</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Std(System.Single[]@,IM.Imaging.Image3D)">
            <summary> Computes the unbiased standard deviation on each band of a 3D image 
            </summary>
            <param name="input">input image</param>
            <param name="output">output array that will contain the variance of each image band</param>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.applyMask(System.Single[],System.Single[])">
            <summary>
            Creates an array containing only values corresponding to a "1" value in the mask
            </summary>
            <param name="input">the input array</param>
            <param name="mask">the binary mask to apply</param>
            <returns>the array with the "mask=1" values</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.AnscombeTransform(System.Single[],System.Single[]@)">
            <summary> Compute the Anscombe transform (Variance Stabilization Transform)
            </summary>
            <param name="input">input array</param>
            <param name="result">result array</param>
            <returns>result array</returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.Entropy(System.Single[])">
            <summary>
            Calculates the array entropy
            </summary>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.SlidingMean2D(IM.Imaging.Image3D,System.Int32,System.Int32)">
            <summary>
            Return an array of the local means over the image
            </summary>
            <param name="input">input image</param>
            <param name="inputChannel">input channel</param>
            <param name="HalfSizeSize">Half size of the sliding window</param>
            <returns></returns>
        </member>
        <member name="M:IM.Library.Mathematics.MathTools.SlidingVar2D(IM.Imaging.Image3D,System.Int32,System.Int32)">
            <summary>
            Return an array of the local variance over the image
            </summary>
            <param name="input">input image</param>
            <param name="inputChannel">input channel</param>
            <param name="HalfSizeSize">Half size of the sliding window</param>
            <returns></returns>
        </member>
        <member name="T:IM.Library.Mathematics.Gradient">
            <summary> Gradient calculation toolbox
            </summary>
            <list type="table">
            <listheader> <term>Version</term> <description>Changes</description> </listheader>
            <item> <term>2.0</term> <description>(AD) multi-threaded</description> </item>
            <item> <term>1.0</term> <description>(AD) first operational build</description> </item>
            </list>
        </member>
        <member name="M:IM.Library.Mathematics.Gradient.ComputeGradient(IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D,IM.Imaging.Axis,IM.Library.GradientDirections,IM.Library.BoundaryConditions)">
            <summary> Computes the gradient of the input image along the specified direction
            </summary>
            <param name="input">the input image</param>
            <param name="inputBand">the input image band to work on</param>
            <param name="output">the output gradient image</param>
            <param name="axis">the axis along which the gradient will be computed</param>
            <param name="direction">the direction used to compute the gradient</param>
            <param name="boundaryCondition">the boundary condition to apply</param>
        </member>
        <member name="M:IM.Library.Mathematics.Gradient.ComputeGradient(IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D,System.Int32,IM.Imaging.Axis,IM.Library.GradientDirections,IM.Library.BoundaryConditions)">
            <summary> Computes the gradient of the input image along the specified direction
            </summary>
            <param name="input">the input image</param>
            <param name="inputBand">the input image band to work on</param>
            <param name="output">the output gradient image</param>
            <param name="outputBand">the output band</param>
            <param name="axis">the axis along which the gradient will be computed</param>
            <param name="direction">the direction used to compute the gradient</param>
            <param name="boundaryCondition">the boundary condition to apply</param>
        </member>
        <member name="M:IM.Library.Mathematics.Gradient.ComputeGradient(IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D,IM.Library.GradientDirections,IM.Library.BoundaryConditions)">
            <summary> Computes the gradient of the input image in all directions and returns the result in a multi-band image
            </summary>
            <param name="input">the input image</param>
            <param name="inputBand">the input image band to work on</param>
            <param name="output">the multi-band output gradient image</param>
            <param name="direction">the direction used to compute the gradient</param>
            <param name="boundaryCondition">the boundary condition to apply</param>
        </member>
        <member name="M:IM.Library.Mathematics.Gradient.ComputeGradient(IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D,IM.Imaging.Image3D,IM.Library.GradientDirections,IM.Library.BoundaryConditions)">
            <summary> Computes the gradient of the input image in all drections
            </summary>
            <param name="input">the input image</param>
            <param name="inputBand">the input image band</param>
            <param name="outputX">the gradient image along X</param>
            <param name="outputY">the gradient image along Y</param>
            <param name="direction">the direction used to compute the gradient</param>
            <param name="boundaryCondition">the boundary condition to apply</param>
        </member>
        <member name="M:IM.Library.Mathematics.Gradient.ComputeGradient(IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D,IM.Imaging.Image3D,IM.Imaging.Image3D,IM.Library.GradientDirections,IM.Library.BoundaryConditions)">
            <summary> Computes the gradient of the input image in all drections
            </summary>
            <param name="input">the input image</param>
            <param name="inputBand">the input image band</param>
            <param name="outputX">the gradient image along X</param>
            <param name="outputY">the gradient image along Y</param>
            <param name="outputZ">the gradient image along Z</param>
            <param name="direction">the direction used to compute the gradient</param>
            <param name="boundaryCondition">the boundary condition to apply</param>
        </member>
        <member name="M:IM.Library.Mathematics.Gradient.ComputeCenteredGradientMax2D(IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D,System.Int32)">
            <summary>
            Compute the gradient maximum along the 4 directions (H-V-D)
            </summary>
            <param name="input">input image</param>
            <param name="inputBand">input channel</param>
            <param name="output">output image</param>
            <param name="outputBand">output channel</param>
        </member>
        <member name="M:IM.Library.Mathematics.Gradient.ComputeGradientAbs2D(IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D,System.Int32,System.Boolean)">
            <summary> Compute the absolute value of the gradient
            </summary>
            <param name="input">input image</param>
            <param name="inputBand">input channel</param>
            <param name="output">gradient norm</param>
        </member>
        <member name="M:IM.Library.Mathematics.Gradient.ComputeGradient2D(IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D,IM.Imaging.Image3D)">
            <summary> Compute the gradient
            </summary>
            <param name="input">input image</param>
            <param name="inputBand">input channel</param>
            <param name="outputRho">gradient norm</param>
            <param name="outputTheta">gradient direction</param>
        </member>
        <member name="M:IM.Library.Mathematics.Gradient.ComputeGradient2D(IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D,IM.Imaging.Image3D,System.Int32)">
            <summary> Compute the gradient
            </summary>
            <param name="input">input image</param>
            <param name="inputBand">input channel</param>
            <param name="outputRho">gradient norm</param>
            <param name="outputTheta">gradient direction</param>
            <param name="SliceIdx">Slice Index for real 3D image</param>
        </member>
        <member name="M:IM.Library.Mathematics.Gradient.GradientVectorFlow(IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D)">
            <summary> Computes the gradient vector flow from the given image
            </summary>
            <param name="input">the input image</param>
            <param name="inputBand">the input band</param>
            <param name="output">a multi-band output image (one band per dimension)</param>
        </member>
        <member name="T:IM.Library.Mathematics.ArrayDistance">
            <remarks> Class providing tools to calculates distances between float arrays
            </remarks>
            <list type="table">
            <listheader> <term>Version</term> <description>Changes</description> </listheader>
            <item><term>2.2</term><description>(TD) Added simple segmentation evaluation on binary images</description></item>
            <item><term>2.1</term><description>(ED) Added Correlation between an image and a kernel</description></item>
            <item> <term>2.0</term><description>(AD) Redesigned to object framework</description> </item>
            <item> <term>1.3</term><description>(TD) Added Infinity norm distance</description> </item>
            <item> <term>1.2</term><description>(TD) Added Manhattan distance</description> </item>
            <item> <term>1.1</term><description>(TD) Added Euclidian distance</description> </item>
            <item> <term>1.0</term><description>(TD) First operational build: distance L^n</description> </item>
            </list>
        </member>
        <member name="M:IM.Library.Mathematics.ArrayDistance.#ctor">
            <summary> Creates a new array distance caculator</summary>
        </member>
        <member name="M:IM.Library.Mathematics.ArrayDistance.LN(System.Single[],System.Single[],System.Double)">
            <summary> Computes the P norm distance between two arrays
            </summary>
            <param name="input1">the input array1</param>
            <param name="input2">the input array2</param>
            <param name="pNorm">the p norm</param>
            <returns>the distance value between the two arrays</returns>
        </member>
        <member name="M:IM.Library.Mathematics.ArrayDistance.LN(System.Single,System.Single,System.Double)">
            <summary> Computes the P norm distance between two values
            </summary>
            <param name="input1">the input value 1</param>
            <param name="input2">the input value 2</param>
            <param name="pNorm">the p norm</param>
            <returns>the distance value between the two values</returns>
        </member>
        <member name="M:IM.Library.Mathematics.ArrayDistance.Euclidian(System.Single[],System.Single[])">
            <summary> Computes the Euclidian distance between two arrays
            </summary>
            <param name="input1">the input array1</param>
            <param name="input2">the input array2</param>
            <returns>the distance value between the two arrays</returns>
        </member>
        <member name="M:IM.Library.Mathematics.ArrayDistance.Euclidian(System.Single,System.Single)">
            <summary> Computes the Euclidian distance between two values
            </summary>
            <param name="input1">the input value1</param>
            <param name="input2">the input value2</param>
            <returns>the distance value between the two values</returns>
        </member>
        <member name="M:IM.Library.Mathematics.ArrayDistance.Hausdorff2D(IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D,System.Int32)">
            <summary>
            
            </summary>
            <param name="input1"></param>
            <param name="Inputchannel1"></param>
            <param name="input2"></param>
            <param name="Inputchannel2"></param>
            <returns></returns>
        </member>
        <member name="M:IM.Library.Mathematics.ArrayDistance.Hausdorff2D(System.Single[][],System.Single[][])">
            <summary>
            
            </summary>
            <param name="input1"></param>
            <param name="input2"></param>
            <returns></returns>
        </member>
        <member name="M:IM.Library.Mathematics.ArrayDistance.DistManhattan(System.Single[],System.Single[])">
            <summary> Computes the Manhattan distance between two arrays
            </summary>
            <param name="input1">the input array1</param>
            <param name="input2">the input array2</param>
            <returns>the distance value between the two arrays</returns>
        </member>
        <member name="M:IM.Library.Mathematics.ArrayDistance.Manhattan(System.Single,System.Single)">
            <summary> Computes the DistManhattan distance between two values
            </summary>
            <param name="input1">the input value1</param>
            <param name="input2">the input value2</param>
            <returns>the distance value between the two values</returns>
        </member>
        <member name="M:IM.Library.Mathematics.ArrayDistance.ZCoefficient(System.Single[],System.Single[])">
            <summary> Computes Z coefficient
            </summary>
            <param name="MaximumSignal">the input Maximum array</param>
            <param name="MinimumSignal">the input Minimum array</param>
            <returns>the Z coefficient value</returns>
        </member>
        <member name="M:IM.Library.Mathematics.ArrayDistance.Kullback_LeiblerDiv(System.Single[],System.Single[])">
            <summary> Computes Kullback_Leibler divergence (relative entropy measure)
            rem.: This measure is non-symmetric.
            </summary>
            <param name="P">True Probability Distribution</param>
            <param name="Q">Arbitrary Probability Distribution (Theory, Model) (no zero)</param>
            <returns>the divergence value</returns>
        </member>
        <member name="M:IM.Library.Mathematics.ArrayDistance.Kullback_LeiblerDivSym(System.Single[],System.Single[])">
            <summary> Computes the Symmetric Kullback_Leibler divergence (relative entropy measure)
            </summary>
            <param name="P">First Probability Distribution (no zero)</param>
            <param name="Q">Second Probability Distribution (no zero)</param>
            <returns>the divergence value</returns>
        </member>
        <member name="M:IM.Library.Mathematics.ArrayDistance.Jeffrey_Divergence(System.Single[],System.Single[])">
            <summary> Computes the Jeffrey divergence
            </summary>
            <param name="P">First Probability Distribution (no zero)</param>
            <param name="Q">Second Probability Distribution (no zero)</param>
            <returns>the divergence value</returns>
        </member>
        <member name="M:IM.Library.Mathematics.ArrayDistance.KolmogorovSmirnov_Distance(System.Single[],System.Single[])">
            <summary> Computes the Kolmogorov-Smirnov Distance
            rem.: defined only in 1D
            </summary>
            <param name="H">First Histogram</param>
            <param name="K">Second Histogram</param>
            <returns>the distance value</returns>
        </member>
        <member name="M:IM.Library.Mathematics.ArrayDistance.InfinityNorm(System.Single[],System.Single[])">
            <summary> Computes the infinity norm distance between two arrays
            </summary>
            <param name="input1">the input array1</param>
            <param name="input2">the input array2</param>
            <returns>the distance value between the two arrays</returns>
        </member>
        <member name="M:IM.Library.Mathematics.ArrayDistance.InfinityNorm(System.Single,System.Single)">
            <summary> Computes the infinity norm distance between two values
            </summary>
            <param name="input1">the input value1</param>
            <param name="input2">the input value2</param>
            <returns>the distance value between the two values</returns>
        </member>
        <member name="M:IM.Library.Mathematics.ArrayDistance.Correlation(IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D,System.Int32,IM.Library.BoundaryConditions)">
            <summary> Computes the correlation between an image and a kernel 
            </summary>
            <param name="input">Image3D </param>
            <param name="band"> input band </param>
            <param name="output">output image</param>
            <param name="bandoutput">output band</param>
            <param name="kernel">kernel</param>
            <param name="bandk">kernel band</param>
            <param name="cond"> Boundary condition</param>
        </member>
        <member name="M:IM.Library.Mathematics.ArrayDistance.Correlation2D(IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D,System.Int32,IM.Library.BoundaryConditions)">
            <summary> Computes the correlation between an image and a kernel 
            </summary>
            <param name="input">Image3D </param>
            <param name="band"> input band </param>
            <param name="output">output image</param>
            <param name="bandoutput">output band</param>
            <param name="kernel">kernel</param>
            <param name="bandk">kernel band</param>
            <param name="cond"> Boundary condition</param>
        </member>
        <member name="M:IM.Library.Mathematics.ArrayDistance.ComputeMutualInformation(IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D,System.Int32)">
            <summary>
            Compute the mutual information between two 3d images 
            </summary>
            <param name="Image0">first image</param>
            <param name="Channel0">first channel</param>
            <param name="Image1">second image</param>
            <param name="Channel1">second channel</param>
            <returns>the mutual information</returns>
        </member>
        <member name="M:IM.Library.Mathematics.ArrayDistance.SimpleSegmentationEvaluation(System.Single[],System.Single[])">
            <summary>
            Compute the distance between two binary array without any spatial consideration
            </summary>
            <param name="input1">First Binary Array</param>
            <param name="input2">Second Binary Array</param>
            <returns>The binary distance (0 : perfect segmentation)</returns>
        </member>
        <member name="M:IM.Library.Mathematics.ArrayDistance.PSNR(IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D,System.Int32)">
            <summary>
            Compute the PSNR value between two images 
            </summary>
            <param name="input1">First Image</param>
            <param name="input2">Second Image</param>
            <returns>exprime en db</returns>
        </member>
        <member name="M:IM.Library.Mathematics.ArrayDistance.PQNoiseModel(System.Single,System.Single)">
            <summary>
            Instensity similarity measure in low-light conditions (Poisson noise case)
            </summary>
            <param name="k">first float</param>
            <param name="l">second float</param>
            <returns></returns>
        </member>
        <member name="M:IM.Library.Mathematics.ArrayDistance.KappaCoefficient(System.Single[],System.Single[])">
            <summary>
            Compute the kappa coefficient between two binary array without any spatial consideration
            </summary>
            <param name="input1">First Binary Array</param>
            <param name="input2">Second Binary Array</param>
            <returns>The binary distance (higher than 0.7 means very good segmentation)</returns>
        </member>
        <member name="T:IM.Library.Mathematics.Interpolation">
            <summary> Toolbox providing various interpolation functions
            </summary>
        </member>
        <member name="M:IM.Library.Mathematics.Interpolation.#ctor">
            <summary> Creates a new instance of the interpolation toolbox 
            </summary>
            <list type="table">
            <listheader> <term>Version</term> <description>Changes</description> </listheader>
            <item> <term>1.1</term> <description>(AD) added 1D (array) interpolation</description> </item>
            <item> <term>1.0</term> <description>(AD) first operational build, supports 2D/3D nearest neighbor and linear image interpolation</description> </item>
            </list>
        </member>
        <member name="M:IM.Library.Mathematics.Interpolation.GetValue(System.Single[],System.Single,IM.Library.InterpolationScheme)">
            <summary> Gets the interpolated array value at the given point
            </summary>
            <param name="array">the input array</param>
            <param name="x">the point</param>
            <param name="scheme">the interpolation scheme to use</param>
            <returns>the image value at the given location</returns>
        </member>
        <member name="M:IM.Library.Mathematics.Interpolation.GetValue(IM.Imaging.Image3D,System.Int32,System.Single,System.Single,IM.Library.InterpolationScheme)">
            <summary> Gets the interpolated image value at the given 2D point
            </summary>
            <param name="image">the input image</param>
            <param name="band">the input band</param>
            <param name="x">the X coordinate</param>
            <param name="y">the Y coordinate</param>
            <param name="scheme">the interpolation scheme to use</param>
            <returns>the image value at the given location</returns>
        </member>
        <member name="M:IM.Library.Mathematics.Interpolation.GetValue(IM.Imaging.Image3D,System.Int32,System.Single,System.Single,System.Single,IM.Library.InterpolationScheme)">
            <summary> Gets the intepolated image value at the given 3D point
            </summary>
            <param name="image">the input image</param>
            <param name="band">the input band</param>
            <param name="x">the X coordinate</param>
            <param name="y">the Y coordinate</param>
            <param name="z">the Z coordinate</param>
            <param name="scheme">the interpolation scheme to use</param>
            <returns>the image value at the given location</returns>
        </member>
        <member name="T:IM.Library.Mathematics.Fuzzy">
            <summary>
            A Class to manipulate fuzzy numbers and fuzzy sets.
            provides a definition of fuzzy numbers as well a logic operators
            </summary>
        </member>
        <member name="M:IM.Library.Mathematics.Fuzzy.Intersection(IM.Library.Mathematics.Fuzzy.FuzzySet,IM.Library.Mathematics.Fuzzy.FuzzySet)">
            <summary>
            Intersection operator between two fuzzy sets, returns the min(s1,s2)
            </summary>
            <param name="s1">Fuzzy set</param>
            <param name="s2">Fuzzy set</param>
            <returns>result Fuzzy set = min(s1,s2)</returns>
        </member>
        <member name="M:IM.Library.Mathematics.Fuzzy.Union(IM.Library.Mathematics.Fuzzy.FuzzySet,IM.Library.Mathematics.Fuzzy.FuzzySet)">
            <summary>
            Union operator between two fuzzy sets, returns the max(s1,s2)
            </summary>
            <param name="s1">Fuzzy set</param>
            <param name="s2">Fuzzy set</param>
            <returns>result Fuzzy set = max(s1,s2)</returns>
        </member>
        <member name="M:IM.Library.Mathematics.Fuzzy.Not(IM.Library.Mathematics.Fuzzy.FuzzySet)">
            <summary>
            Returns the inverse of a fuzzy set. the set is not modified
            </summary>
            <param name="s">set to inverse</param>
            <returns>1-s</returns>
        </member>
        <member name="T:IM.Library.Mathematics.Fuzzy.FuzzySet">
            <summary>
            Defines a fuzzy set by a belonging function partly linear
            </summary>
        </member>
        <member name="F:IM.Library.Mathematics.Fuzzy.FuzzySet.gains">
            <summary>
            Arrays to precompute the parameters of each portion of the belonging function
            </summary>
        </member>
        <member name="M:IM.Library.Mathematics.Fuzzy.FuzzySet.#ctor(System.Single[0:,0:])">
            <summary>
            Constructor for a fuzzy set defined by two sorted arrays that gives coordinates of the main point of beloging function
            points must be a nx2 array with:
            - points[*,0] the value of the property
            - points[*,1] of much it belong to the fuzzy set must be in [0,1].
            </summary>
            <param name="points">Points where the function is defined</param>
        </member>
        <member name="M:IM.Library.Mathematics.Fuzzy.FuzzySet.belongs(System.Single)">
            <summary>
            Tells how much a value belongs to the fuzzy set
            </summary>
            <param name="V">property value</param>
        </member>
        <member name="M:IM.Library.Mathematics.Fuzzy.FuzzySet.Clone">
            <summary>
            Returns a clone of the current Fuzzy set
            </summary>
            <returns>an exact but distinct copy of the current fuzzy set</returns>
        </member>
        <member name="M:IM.Library.Mathematics.Fuzzy.FuzzySet.inverse">
            <summary>
            Inverse the fuzzy set (1-fuzzy set)
            </summary>
        </member>
        <member name="F:IM.Library.Mathematics.Fuzzy.FuzzyRule.ruleType">
            <summary>
            Will be used to define how to evaluate the rule
            </summary>
        </member>
        <member name="F:IM.Library.Mathematics.Fuzzy.FuzzyRule.currentResult">
            <summary>
            Saves the result of prior evaluation until lValue is changed
            </summary>
        </member>
        <member name="M:IM.Library.Mathematics.Fuzzy.FuzzyRule.#ctor(IM.Library.Mathematics.Fuzzy.FuzzySet)">
            <summary>
            Build a rule defined a single fuzzy set
            </summary>
            <param name="set">the set</param>
        </member>
        <member name="M:IM.Library.Mathematics.Fuzzy.FuzzyRule.#ctor(IM.Library.Mathematics.Fuzzy.FuzzyRule.modifierEnum,IM.Library.Mathematics.Fuzzy.FuzzyRule)">
            <summary>
            Build a rule defined a FuzzyRule and a modifier
            </summary>
            <param name="m"> modifier: see FuzzyRule.modifierEnum </param>
            <param name="rule">the set</param>
        </member>
        <member name="M:IM.Library.Mathematics.Fuzzy.FuzzyRule.#ctor(IM.Library.Mathematics.Fuzzy.FuzzyRule.operatorEnum,IM.Library.Mathematics.Fuzzy.FuzzyRule,IM.Library.Mathematics.Fuzzy.FuzzyRule)">
            <summary>
            Build a rule by combining two different rules
            </summary>
            <param name="o"> operator  (and/or - see FuzzyRule.operatorEnum)</param>
            <param name="rule1"> First rule</param>
            <param name="rule2"> Second rule</param>
        </member>
        <member name="M:IM.Library.Mathematics.Fuzzy.FuzzyRule.setLValue(System.Single)">
            <summary>
            Set a value of a property to be used during rule evaluation
            </summary>
            <param name="V"></param>
        </member>
        <member name="M:IM.Library.Mathematics.Fuzzy.FuzzyRule.Evaluate">
            <summary>
            Evaluate the rule, goes down the tree and returns a value in [0,1]. 
            Throws an exception if all lValues where not set properly
            TODO : no check is performed about rule validity
            </summary>
            <returns>A value corresponding to the evaluation of the rule</returns>
        </member>
        <member name="P:IM.Library.Mathematics.Fuzzy.FuzzyRule.rule1">
            <summary>
            Read only access to the rules for consistancy checking
            </summary>
        </member>
        <member name="P:IM.Library.Mathematics.Fuzzy.FuzzyRule.isAtom">
            <summary>
            Returns true if the rule is an atom
            </summary>
        </member>
        <member name="T:IM.Library.Mathematics.Fuzzy.FuzzyKnowledgeBase">
            <summary>
            A class to manage a set of rules
            </summary>
        </member>
        <member name="F:IM.Library.Mathematics.Fuzzy.FuzzyKnowledgeBase.Rules">
            <summary>
            List of the rules that can be evaluated
            </summary>
        </member>
        <member name="F:IM.Library.Mathematics.Fuzzy.FuzzyKnowledgeBase.Atoms">
            <summary>
            List of the rules that can be instanciated
            </summary>
        </member>
        <member name="M:IM.Library.Mathematics.Fuzzy.FuzzyKnowledgeBase.#ctor">
            <summary>
            Creates an empty knowledge base
            </summary>
        </member>
        <member name="M:IM.Library.Mathematics.Fuzzy.FuzzyKnowledgeBase.AddAtom(IM.Library.Mathematics.Fuzzy.FuzzySet,System.String)">
            <summary>
            Add an atom in the knowledge base
            </summary>
            <param name="s">A fuzzy set corresponding describing the property</param>
            <param name="name">The name of the property</param>
        </member>
        <member name="M:IM.Library.Mathematics.Fuzzy.FuzzyKnowledgeBase.AddRule(IM.Library.Mathematics.Fuzzy.FuzzyRule,System.String)">
            <summary>
            Add a complex rule in the knowledge base. A rule can only be added if it references existing rules
            </summary>
            <param name="r">The rule </param>
            <param name="name">name of the rule</param>
        </member>
        <member name="M:IM.Library.Mathematics.Fuzzy.FuzzyKnowledgeBase.Evaluate(System.String)">
            <summary>
            Evaluate a rule in the base. All lValues have to be set priorly,
            Will raise an exception otherwise
            </summary>
            <param name="ruleName">Name of the rule</param>
            <returns></returns>
        </member>
        <member name="T:IM.Library.Mathematics.Convolution">
            <summary> Class defining convolution operations.
            Uses a temporary buffer for some routines</summary>
            <list type="table">
            <listheader> <term>Version</term> <description>Changes</description> </listheader>
            <item> <term>3.4</term> <description>(AD) Just faster n faster !! (from -25 to -77%)</description> </item>
            <item> <term>3.3</term> <description>(AD) Bug correction for 2D and 3D point-wise convolution</description> </item>
            <item> <term>3.2</term> <description>(AD) Extended 2D routines to process all slices for 3D stacks</description> </item>
            <item> <term>3.1</term> <description>(AG) Added fast convolution methods for separable kernels</description> </item>
            <item> <term>3.0</term> <description>(AD) Class not static anymore (for threading purposes)</description> </item>
            <item> <term>2.5</term> <description>(ED) Added point-wise convolution routines</description> </item>
            <item> <term>2.4</term> <description>(AD) Boundary conditions are each treated in a specific method, reducing complexity</description> </item>
            <item> <term>2.3</term> <description>(AD) Fixed a calulcation error in the gradient convolution</description> </item>
            <item> <term>2.2</term> <description>(AD) Added multiple boundary conditions support</description> </item>
            <item> <term>2.1</term> <description>(AD) Fixed a bug on the index calculations on the image boundary for reflecting conditions</description> </item>
            <item> <term>2.0</term> <description>(AD) Redesigned class, entry points and internal methods. Should be much simpler to use</description> </item>
            <item> <term>1.2</term> <description>(AD) overloaded methods to support various types of input</description> </item>
            <item> <term>1.1</term> <description>(AD) added "Gradient*" kernels to support "Kernel" class v1.1.0</description> </item>
            <item> <term>1.0</term> <description>(AD) first operational build, supports "Kernel" class v1.0.0</description> </item>
            </list>
        </member>
        <member name="F:IM.Library.Mathematics.Convolution.bufferImage">
            <summary> Temporary buffer used by some routines
            </summary>
        </member>
        <member name="M:IM.Library.Mathematics.Convolution.#ctor">
            <summary> Builds a new instance of the Convolution Toolbox
            </summary>
        </member>
        <member name="M:IM.Library.Mathematics.Convolution.convolveLineMirror(System.Single[],System.Single[],System.Single[],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary> Utility function that convolves a whole line using the specified offsets
            </summary>
            <param name="input">the data array to convolve (the image data)</param>
            <param name="output">the convolution output</param>
            <param name="kernel">the kernel</param>
            <param name="halfKernelLengthPixelStride">the kernel radius in pixels</param>
            <param name="offset">the starting offset of the convolution</param>
            <param name="pixelStride">the distance in pixels between two points of the line to convolve</param>
            <param name="nbElements">the number of points to convolve in the line</param>
        </member>
        <member name="M:IM.Library.Mathematics.Convolution.convolveLineZero(System.Single[],System.Single[],System.Single[],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary> Utility function that convolves a whole line using the specified offsets
            </summary>
            <param name="input">the data array to convolve (the image data)</param>
            <param name="output">the convolution output</param>
            <param name="kernel">the kernel</param>
            <param name="halfKernelLengthPixelStride">the kernel radius in pixels</param>
            <param name="offset">the starting offset of the convolution</param>
            <param name="pixelStride">the distance in pixels between two points of the line to convolve</param>
            <param name="nbElements">the number of points to convolve in the line</param>
        </member>
        <member name="M:IM.Library.Mathematics.Convolution.Convolve1D_X(IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D,IM.Library.BoundaryConditions)">
            <summary> 1D convolution along the X axis </summary>
            <param name="inputImage">The input image</param>
            <param name="inputBand">The input band</param>
            <param name="outputImage">The output image</param>
            <param name="outputBand">The output band</param>
            <param name="kernel1D">The kernel to convolve the image with</param>
            <param name="condition">The boundary conditions to use</param>
        </member>
        <member name="M:IM.Library.Mathematics.Convolution.Convolve1D_Y(IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D,IM.Library.BoundaryConditions)">
            <summary> 1D convolution along the Y axis </summary>
            <param name="inputImage">The input image</param>
            <param name="inputBand">The input band</param>
            <param name="outputImage">The output image</param>
            <param name="outputBand">The output band</param>
            <param name="kernel1D">The kernel to convolve the image with</param>
            <param name="condition">The boundary conditions to use</param>
        </member>
        <member name="M:IM.Library.Mathematics.Convolution.Convolve1D_Z(IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D,IM.Library.BoundaryConditions)">
            <summary> 1D convolution along the Z axis </summary>
            <param name="inputImage">The input image</param>
            <param name="inputBand">The input band</param>
            <param name="outputImage">The output image</param>
            <param name="outputBand">The output band</param>
            <param name="kernel1D">The kernel to convolve the image with</param>
            <param name="condition">The boundary conditions to use</param>
        </member>
        <member name="M:IM.Library.Mathematics.Convolution.Convolve2D(IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D,IM.Library.BoundaryConditions)">
            <summary> Convolve an image with a 2D kernel
            </summary>
            <param name="input">The input image</param>
            <param name="inputBand">The input band</param>
            <param name="output">The output image</param>
            <param name="outputBand">The output band</param>
            <param name="kernel2D">The kernel to convolve the image with</param>
            <param name="condition">The boundary conditions to use</param>
        </member>
        <member name="M:IM.Library.Mathematics.Convolution.ConvolveZeroBoundary2D(IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D)">
            <summary> Convolve an image with a 2D kernel with zero boundary condition
            </summary>
            <param name="inputImage">The input image</param>
            <param name="inputBand">The input band</param>
            <param name="outputImage">The output image</param>
            <param name="outputBand">The output band</param>
            <param name="kernel2D">The kernel to convolve the image with</param>
        </member>
        <member name="M:IM.Library.Mathematics.Convolution.ConvolveMirrorBoundary2D(IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D)">
            <summary> Convolve an image with a 2D kernel with reflecting boundary condition
            </summary>
            <param name="inputImage">The input image</param>
            <param name="inputBand">The input band</param>
            <param name="outputImage">The output image</param>
            <param name="outputBand">The output band</param>
            <param name="kernel2D">The kernel to convolve the image with</param>
        </member>
        <member name="M:IM.Library.Mathematics.Convolution.Convolve3D(IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D,IM.Library.BoundaryConditions)">
            <summary> Convolve an image with a 3D kernel
            </summary>
            <param name="input">The input image</param>
            <param name="inputBand">The input band</param>
            <param name="output">The output image</param>
            <param name="outputBand">The output band</param>
            <param name="kernel3D">The kernel to convolve the image with</param>
            <param name="condition">The boundary conditions to use</param>
        </member>
        <member name="M:IM.Library.Mathematics.Convolution.ConvolveZeroBoundary3D(IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D)">
            <summary> Convolve an image with a 3D kernel with zero boundary condition
            </summary>
            <param name="inputImage">The input image</param>
            <param name="inputBand">The input band</param>
            <param name="outputImage">The output image</param>
            <param name="outputBand">The output band</param>
            <param name="kernel3D">The kernel to convolve the image with</param>
        </member>
        <member name="M:IM.Library.Mathematics.Convolution.ConvolveMirrorBoundary3D(IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D)">
            <summary> Convolve an image with a 3D kernel with reflecting boundary condition
            </summary>
            <param name="inputImage">The input image</param>
            <param name="inputBand">The input band</param>
            <param name="outputImage">The output image</param>
            <param name="outputBand">The output band</param>
            <param name="kernel3D">The kernel to convolve the image with</param>
        </member>
        <member name="M:IM.Library.Mathematics.Convolution.Convolve1D_X(IM.Imaging.Image3D,System.Int32,System.Int32[],System.Single[],IM.Imaging.Image3D,IM.Library.BoundaryConditions)">
            <summary> Convolve some points of an image with a given kernel
            </summary>
            <param name="inputImage">The input image</param>
            <param name="inputBand">the input image band</param>
            <param name="pointsList"> The indices of points to convolve</param>
            <param name="output"> The output vector of convolved points</param>
            <param name="kernel1D">The kernel to convolve the image with</param>
            <param name="condition">The boundary conditions to use</param>
        </member>
        <member name="M:IM.Library.Mathematics.Convolution.Convolve1D_Y(IM.Imaging.Image3D,System.Int32,System.Int32[],System.Single[],IM.Imaging.Image3D,IM.Library.BoundaryConditions)">
            <summary> Convolve some points of an image with a given kernel
            </summary>
            <param name="inputImage">The input image</param>
            <param name="inputBand">the input image band</param>
            <param name="pointsList"> The indices of points to convolve</param>
            <param name="output"> The output vector of convolved points</param>
            <param name="kernel1D">The kernel to convolve the image with</param>
            <param name="condition">The boundary conditions to use</param>
        </member>
        <member name="M:IM.Library.Mathematics.Convolution.Convolve1D_Z(IM.Imaging.Image3D,System.Int32,System.Int32[],System.Single[],IM.Imaging.Image3D,IM.Library.BoundaryConditions)">
            <summary> Convolve some points of an image with a given kernel
            </summary>
            <param name="inputImage">The input image</param>
            <param name="inputBand">the input image band</param>
            <param name="pointsList"> The indices of points to convolve</param>
            <param name="output"> The output vector of convolved points</param>
            <param name="kernel1D">The kernel to convolve the image with</param>
            <param name="condition">The boundary conditions to use</param>
        </member>
        <member name="M:IM.Library.Mathematics.Convolution.Convolve2D(IM.Imaging.Image3D,System.Int32,System.Int32[],System.Single[],IM.Imaging.Image3D,IM.Library.BoundaryConditions)">
            <summary> Convolve an image at some points with a 2D kernel
            </summary>
            <param name="input">The input image</param>
            <param name="inputBand">The input image</param>
            <param name="listPoints"> The list of points</param>
            <param name="output">The output image</param>
            <param name="kernel2D">The kernel to convolve the image with</param>
            <param name="condition">The boundary conditions to use</param>
        </member>
        <member name="M:IM.Library.Mathematics.Convolution.ConvolveZeroBoundaryPoints2D(IM.Imaging.Image3D,System.Int32,System.Int32[],System.Single[],IM.Imaging.Image3D)">
            <summary> Convolve an image at some points with a 2D kernel with zero boundary condition
            </summary>
            <param name="input">The input image</param>
            <param name="inputBand">The input image</param>
            <param name="listPoints"> The list of points </param>
            <param name="output">The output for each of listPoints </param>
            <param name="kernel2D">The kernel to convolve the image with</param>
        </member>
        <member name="M:IM.Library.Mathematics.Convolution.ConvolveMirrorBoundaryPoints2D(IM.Imaging.Image3D,System.Int32,System.Int32[],System.Single[],IM.Imaging.Image3D)">
            <summary> Convolve an image at some points with a 2D kernel with reflecting boundary condition
            </summary>
            <param name="input">The input image</param>
            <param name="inputBand">The input image</param>
            <param name="listPoints"> The list of points</param>
            <param name="output">The output for each of listPoints</param>
            <param name="kernel2D">The kernel to convolve the image with</param>
        </member>
        <member name="M:IM.Library.Mathematics.Convolution.ConvolveMirrorBoundaryPointWiseGaussian2D(IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D)">
            <summary> Convolve each pixel of an image by a specific Gaussian Kernel
            </summary>
            <param name="input">the input image</param>
            <param name="inputBand">the input band</param>
            <param name="output">the output image</param>
            <param name="outputBand">the output band</param>
            <param name="sigmas">an image of same size as input containing the gaussian variance for each pixel</param>
        </member>
        <member name="M:IM.Library.Mathematics.Convolution.Convolve3D(IM.Imaging.Image3D,System.Int32,System.Single[],System.Int32[],IM.Imaging.Image3D,IM.Library.BoundaryConditions)">
            <summary> Convolve an image at some points with a 3D kernel
            </summary>
            <param name="input">The input image</param>
            <param name="inputBand">The input image</param>
            <param name="pointsList"> The list of points </param>
            <param name="output">The output for each of listPoints </param>
            <param name="kernel3D">The kernel to convolve the image with</param>
            <param name="condition">The boundary conditions to use</param>
        </member>
        <member name="M:IM.Library.Mathematics.Convolution.ConvolveZeroBoundaryPoints3D(IM.Imaging.Image3D,System.Int32,System.Int32[],System.Single[],IM.Imaging.Image3D)">
            <summary> Convolve an image at some points with a 3D kernel with zero boundary condition
            </summary>
            <param name="input">The input image</param>
            <param name="inputBand">The input image</param>
            <param name="pointsList"> The list of points </param>
            <param name="output">The output for each of listPoints </param>
            <param name="kernel3D">The kernel to convolve the image with</param>
        </member>
        <member name="M:IM.Library.Mathematics.Convolution.ConvolveMirrorBoundaryPoints3D(IM.Imaging.Image3D,System.Int32,System.Int32[],System.Single[],IM.Imaging.Image3D)">
            <summary> Convolve an image at some points with a 3D kernel with reflecting boundary condition
            </summary>
            <param name="input">The input image</param>
            <param name="inputBand">The input image</param>
            <param name="pointsList"> The list of points </param>
            <param name="output">The output for each of listPoints </param>
            <param name="kernel3D">The kernel to convolve the image with</param>
        </member>
        <member name="M:IM.Library.Mathematics.Convolution.ConvolveFast(IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D)">
            <summary> Fast separable convolution with a unique 1D kernel
            </summary>
            <param name="input">The input image to convolve</param>
            <param name="inputBand">The input band receiving the result</param>
            <param name="output">The image receiving the result</param>
            <param name="outputBand">The output band receiving the result</param>
            <param name="kernel1D">The one dimensional kernel for all directions</param>
        </member>
        <member name="M:IM.Library.Mathematics.Convolution.ConvolveFast(IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D,IM.Imaging.Image3D)">
            <summary> Fast 2D separable convolution. If the input is 3D, each slice is processed separately
            </summary>
            <param name="inputImage">The input image to convolve</param>
            <param name="inputBand">The input image to convolve</param>
            <param name="outputImage">The image into wich storing the result (can be the input image)</param>
            <param name="outputBand">The image into wich storing the result</param>
            <param name="kernel1DX">The one dimensional kernel in X direction</param>
            <param name="kernel1DY">The one dimensional kernel in Y direction</param>
        </member>
        <member name="M:IM.Library.Mathematics.Convolution.ConvolveFast(IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D,IM.Imaging.Image3D,IM.Imaging.Image3D)">
            <summary> Fast 3D separable convolution
            </summary>
            <param name="inputImage">The input image to convolve</param>
            <param name="inputBand">The input image to convolve</param>
            <param name="outputImage">The image into wich storing the result</param>
            <param name="outputBand">The image into wich storing the result</param>
            <param name="kernel1DX">The one dimensional kernel in X direction</param>
            <param name="kernel1DY">The one dimensional kernel in Y direction</param>
            <param name="kernel1DZ">The one dimensional kernel in Z direction</param>
        </member>
        <member name="M:IM.Library.Mathematics.Convolution.ConvolveFast(IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D,IM.Library.BoundaryConditions)">
            <summary> Fast separable convolution with a unique 1D kernel
            </summary>
            <param name="input">The input image to convolve</param>
            <param name="inputBand">The input band receiving the result</param>
            <param name="output">The image receiving the result (may be the input image)</param>
            <param name="outputBand">The output band receiving the result</param>
            <param name="kernel1D">The one dimensional kernel for all directions</param>
            <param name="condition">The boundary condition to use</param>
        </member>
        <member name="M:IM.Library.Mathematics.Convolution.ConvolveFast(IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D,IM.Imaging.Image3D,IM.Library.BoundaryConditions)">
            <summary> Fast 2D separable convolution. If the input is 3D, each slice is processed separately
            </summary>
            <param name="inputImage">The input image to convolve</param>
            <param name="inputBand">The input image to convolve</param>
            <param name="outputImage">The image into wich storing the result (can be the input image)</param>
            <param name="outputBand">The image into wich storing the result</param>
            <param name="kernel1DX">The one dimensional kernel in X direction</param>
            <param name="kernel1DY">The one dimensional kernel in Y direction</param>
            <param name="condition">The boundary condition to use</param>
        </member>
        <member name="M:IM.Library.Mathematics.Convolution.ConvolveFast(IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D,System.Int32,IM.Imaging.Image3D,IM.Imaging.Image3D,IM.Imaging.Image3D,IM.Library.BoundaryConditions)">
            <summary> Fast 3D separable convolution
            </summary>
            <param name="inputImage">The input image to convolve</param>
            <param name="inputBand">The input image to convolve</param>
            <param name="outputImage">The image into wich storing the result</param>
            <param name="outputBand">The image into wich storing the result</param>
            <param name="kernel1DX">The one dimensional kernel in X direction</param>
            <param name="kernel1DY">The one dimensional kernel in Y direction</param>
            <param name="kernel1DZ">The one dimensional kernel in Z direction</param>
            <param name="condition">The boundary condition to use</param>
        </member>
        <member name="M:IM.Library.Mathematics.Convolution.Dispose">
            <summary> Clears the temporary buffer used by the convolution routines
            </summary>
        </member>
        <member name="P:IM.Library.Mathematics.Convolution.BufferImage">
            <summary> Gets the convolver's temporary buffer
            </summary>
        </member>
    </members>
</doc>
